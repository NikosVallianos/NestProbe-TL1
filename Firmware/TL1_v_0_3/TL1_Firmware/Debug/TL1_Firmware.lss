
TL1_Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  0000109c  00001130  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000109c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000c1  00800106  00800106  00001136  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001136  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001168  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000490  00000000  00000000  000011a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003ef2  00000000  00000000  00001638  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017b9  00000000  00000000  0000552a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000249f  00000000  00000000  00006ce3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a88  00000000  00000000  00009184  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000111d  00000000  00000000  00009c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002257  00000000  00000000  0000ad29  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000470  00000000  00000000  0000cf80  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 e7 00 	jmp	0x1ce	; 0x1ce <__vector_9>
      28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__vector_18>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d8 e0       	ldi	r29, 0x08	; 8
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	ec e9       	ldi	r30, 0x9C	; 156
      c8:	f0 e1       	ldi	r31, 0x10	; 16
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	a6 30       	cpi	r26, 0x06	; 6
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	21 e0       	ldi	r18, 0x01	; 1
      d8:	a6 e0       	ldi	r26, 0x06	; 6
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a7 3c       	cpi	r26, 0xC7	; 199
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 6e 03 	call	0x6dc	; 0x6dc <main>
      ea:	0c 94 4c 08 	jmp	0x1098	; 0x1098 <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <adcEnable>:
      f2:	e4 e6       	ldi	r30, 0x64	; 100
      f4:	f0 e0       	ldi	r31, 0x00	; 0
      f6:	80 81       	ld	r24, Z
      f8:	8e 7f       	andi	r24, 0xFE	; 254
      fa:	80 83       	st	Z, r24
      fc:	ec e7       	ldi	r30, 0x7C	; 124
      fe:	f0 e0       	ldi	r31, 0x00	; 0
     100:	80 81       	ld	r24, Z
     102:	8f 77       	andi	r24, 0x7F	; 127
     104:	80 83       	st	Z, r24
     106:	80 81       	ld	r24, Z
     108:	80 64       	ori	r24, 0x40	; 64
     10a:	80 83       	st	Z, r24
     10c:	aa e7       	ldi	r26, 0x7A	; 122
     10e:	b0 e0       	ldi	r27, 0x00	; 0
     110:	8c 91       	ld	r24, X
     112:	86 60       	ori	r24, 0x06	; 6
     114:	8c 93       	st	X, r24
     116:	8c 91       	ld	r24, X
     118:	80 68       	ori	r24, 0x80	; 128
     11a:	8c 93       	st	X, r24
     11c:	80 81       	ld	r24, Z
     11e:	80 7f       	andi	r24, 0xF0	; 240
     120:	80 83       	st	Z, r24
     122:	80 81       	ld	r24, Z
     124:	8e 60       	ori	r24, 0x0E	; 14
     126:	80 83       	st	Z, r24
     128:	08 95       	ret

0000012a <adcDisable>:
     12a:	ea e7       	ldi	r30, 0x7A	; 122
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	80 81       	ld	r24, Z
     130:	8f 77       	andi	r24, 0x7F	; 127
     132:	80 83       	st	Z, r24
     134:	e4 e6       	ldi	r30, 0x64	; 100
     136:	f0 e0       	ldi	r31, 0x00	; 0
     138:	80 81       	ld	r24, Z
     13a:	81 60       	ori	r24, 0x01	; 1
     13c:	80 83       	st	Z, r24
     13e:	08 95       	ret

00000140 <adcReadVoltage>:
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	0e 94 79 00 	call	0xf2	; 0xf2 <adcEnable>
     148:	94 e1       	ldi	r25, 0x14	; 20
     14a:	ea e7       	ldi	r30, 0x7A	; 122
     14c:	f0 e0       	ldi	r31, 0x00	; 0
     14e:	a8 e7       	ldi	r26, 0x78	; 120
     150:	b0 e0       	ldi	r27, 0x00	; 0
     152:	80 81       	ld	r24, Z
     154:	80 64       	ori	r24, 0x40	; 64
     156:	80 83       	st	Z, r24
     158:	80 81       	ld	r24, Z
     15a:	86 fd       	sbrc	r24, 6
     15c:	fd cf       	rjmp	.-6      	; 0x158 <adcReadVoltage+0x18>
     15e:	cd 91       	ld	r28, X+
     160:	dc 91       	ld	r29, X
     162:	11 97       	sbiw	r26, 0x01	; 1
     164:	91 50       	subi	r25, 0x01	; 1
     166:	a9 f7       	brne	.-22     	; 0x152 <adcReadVoltage+0x12>
     168:	0e 94 95 00 	call	0x12a	; 0x12a <adcDisable>
     16c:	ce 01       	movw	r24, r28
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <errorInitFlags>:
     174:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <__data_end+0x1>
     178:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <__data_end>
     17c:	08 95       	ret

0000017e <errorSetFlag>:
     17e:	21 e0       	ldi	r18, 0x01	; 1
     180:	30 e0       	ldi	r19, 0x00	; 0
     182:	02 c0       	rjmp	.+4      	; 0x188 <errorSetFlag+0xa>
     184:	22 0f       	add	r18, r18
     186:	33 1f       	adc	r19, r19
     188:	8a 95       	dec	r24
     18a:	e2 f7       	brpl	.-8      	; 0x184 <errorSetFlag+0x6>
     18c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
     190:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <__data_end+0x1>
     194:	28 2b       	or	r18, r24
     196:	39 2b       	or	r19, r25
     198:	30 93 07 01 	sts	0x0107, r19	; 0x800107 <__data_end+0x1>
     19c:	20 93 06 01 	sts	0x0106, r18	; 0x800106 <__data_end>
     1a0:	08 95       	ret

000001a2 <errorClearAll>:
     1a2:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <__data_end+0x1>
     1a6:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <__data_end>
     1aa:	08 95       	ret

000001ac <errorGetFlags>:
     1ac:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
     1b0:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <__data_end+0x1>
     1b4:	08 95       	ret

000001b6 <indicatorInitialize>:
     1b6:	69 9a       	sbi	0x0d, 1	; 13
     1b8:	71 98       	cbi	0x0e, 1	; 14
     1ba:	08 95       	ret

000001bc <indicatorShortBlink>:
     1bc:	71 9a       	sbi	0x0e, 1	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1be:	8f ec       	ldi	r24, 0xCF	; 207
     1c0:	97 e0       	ldi	r25, 0x07	; 7
     1c2:	01 97       	sbiw	r24, 0x01	; 1
     1c4:	f1 f7       	brne	.-4      	; 0x1c2 <indicatorShortBlink+0x6>
     1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <indicatorShortBlink+0xc>
     1c8:	00 00       	nop
     1ca:	71 98       	cbi	0x0e, 1	; 14
     1cc:	08 95       	ret

000001ce <__vector_9>:


/*
 * Timer 2 is the Real Time Counter, set to fire every 8 seconds.
 */
ISR(TIMER2_OVF_vect) {
     1ce:	1f 92       	push	r1
     1d0:	0f 92       	push	r0
     1d2:	0f b6       	in	r0, 0x3f	; 63
     1d4:	0f 92       	push	r0
     1d6:	11 24       	eor	r1, r1
     1d8:	8f 93       	push	r24
     1da:	9f 93       	push	r25
	logger_eightseconds_count++;
     1dc:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <logger_eightseconds_count>
     1e0:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <logger_eightseconds_count+0x1>
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <logger_eightseconds_count+0x1>
     1ea:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <logger_eightseconds_count>
}
     1ee:	9f 91       	pop	r25
     1f0:	8f 91       	pop	r24
     1f2:	0f 90       	pop	r0
     1f4:	0f be       	out	0x3f, r0	; 63
     1f6:	0f 90       	pop	r0
     1f8:	1f 90       	pop	r1
     1fa:	18 95       	reti

000001fc <__vector_18>:



ISR(USART0_RX_vect) {
     1fc:	1f 92       	push	r1
     1fe:	0f 92       	push	r0
     200:	0f b6       	in	r0, 0x3f	; 63
     202:	0f 92       	push	r0
     204:	11 24       	eor	r1, r1
     206:	2f 93       	push	r18
     208:	3f 93       	push	r19
     20a:	4f 93       	push	r20
     20c:	5f 93       	push	r21
     20e:	6f 93       	push	r22
     210:	7f 93       	push	r23
     212:	8f 93       	push	r24
     214:	9f 93       	push	r25
     216:	af 93       	push	r26
     218:	bf 93       	push	r27
     21a:	ef 93       	push	r30
     21c:	ff 93       	push	r31
	if (rx_buffer_index<RX_BUFFER_LENGTH) {
     21e:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <rx_buffer_index>
     222:	84 31       	cpi	r24, 0x14	; 20
     224:	70 f4       	brcc	.+28     	; 0x242 <__vector_18+0x46>
		rx_buffer_array[rx_buffer_index] = UDR0;
     226:	e0 91 28 01 	lds	r30, 0x0128	; 0x800128 <rx_buffer_index>
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     230:	e4 5f       	subi	r30, 0xF4	; 244
     232:	fe 4f       	sbci	r31, 0xFE	; 254
     234:	80 83       	st	Z, r24
		rx_buffer_index++;	
     236:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <rx_buffer_index>
     23a:	8f 5f       	subi	r24, 0xFF	; 255
     23c:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <rx_buffer_index>
     240:	04 c0       	rjmp	.+8      	; 0x24a <__vector_18+0x4e>
	} else {
		errorSetFlag(ERROR_FLAG_RX_BUFFER_OVF);
     242:	83 e0       	ldi	r24, 0x03	; 3
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 bf 00 	call	0x17e	; 0x17e <errorSetFlag>
	}
}
     24a:	ff 91       	pop	r31
     24c:	ef 91       	pop	r30
     24e:	bf 91       	pop	r27
     250:	af 91       	pop	r26
     252:	9f 91       	pop	r25
     254:	8f 91       	pop	r24
     256:	7f 91       	pop	r23
     258:	6f 91       	pop	r22
     25a:	5f 91       	pop	r21
     25c:	4f 91       	pop	r20
     25e:	3f 91       	pop	r19
     260:	2f 91       	pop	r18
     262:	0f 90       	pop	r0
     264:	0f be       	out	0x3f, r0	; 63
     266:	0f 90       	pop	r0
     268:	1f 90       	pop	r1
     26a:	18 95       	reti

0000026c <rxBufferClear>:


/*
 * Clear the rx buffer and its index.
 */
void rxBufferClear(void) {
     26c:	80 e0       	ldi	r24, 0x00	; 0
     26e:	90 e0       	ldi	r25, 0x00	; 0
	for(uint8_t i=0; i<RX_BUFFER_LENGTH; i++) {
		rx_buffer_array[i] = 0;
     270:	fc 01       	movw	r30, r24
     272:	e4 5f       	subi	r30, 0xF4	; 244
     274:	fe 4f       	sbci	r31, 0xFE	; 254
     276:	10 82       	st	Z, r1
     278:	01 96       	adiw	r24, 0x01	; 1

/*
 * Clear the rx buffer and its index.
 */
void rxBufferClear(void) {
	for(uint8_t i=0; i<RX_BUFFER_LENGTH; i++) {
     27a:	84 31       	cpi	r24, 0x14	; 20
     27c:	91 05       	cpc	r25, r1
     27e:	c1 f7       	brne	.-16     	; 0x270 <rxBufferClear+0x4>
		rx_buffer_array[i] = 0;
	}
	rx_buffer_index = 0;
     280:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <rx_buffer_index>
     284:	08 95       	ret

00000286 <rxBufferIsAllZeros>:
}

uint8_t rxBufferIsAllZeros(void) {
	for (uint8_t i=1; i<20; i++) {
		if (rx_buffer_array[i]!=0) return 0;
     286:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rx_buffer_array+0x1>
     28a:	81 11       	cpse	r24, r1
     28c:	0f c0       	rjmp	.+30     	; 0x2ac <rxBufferIsAllZeros+0x26>
     28e:	22 e0       	ldi	r18, 0x02	; 2
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	f9 01       	movw	r30, r18
     294:	e4 5f       	subi	r30, 0xF4	; 244
     296:	fe 4f       	sbci	r31, 0xFE	; 254
     298:	90 81       	ld	r25, Z
     29a:	91 11       	cpse	r25, r1
     29c:	08 c0       	rjmp	.+16     	; 0x2ae <rxBufferIsAllZeros+0x28>
     29e:	2f 5f       	subi	r18, 0xFF	; 255
     2a0:	3f 4f       	sbci	r19, 0xFF	; 255
	}
	rx_buffer_index = 0;
}

uint8_t rxBufferIsAllZeros(void) {
	for (uint8_t i=1; i<20; i++) {
     2a2:	24 31       	cpi	r18, 0x14	; 20
     2a4:	31 05       	cpc	r19, r1
     2a6:	a9 f7       	brne	.-22     	; 0x292 <rxBufferIsAllZeros+0xc>
		if (rx_buffer_array[i]!=0) return 0;
	}
	return 1;
     2a8:	81 e0       	ldi	r24, 0x01	; 1
     2aa:	08 95       	ret
	rx_buffer_index = 0;
}

uint8_t rxBufferIsAllZeros(void) {
	for (uint8_t i=1; i<20; i++) {
		if (rx_buffer_array[i]!=0) return 0;
     2ac:	80 e0       	ldi	r24, 0x00	; 0
	}
	return 1;
}
     2ae:	08 95       	ret

000002b0 <rxBufferCommandIsReady>:

uint8_t rxBufferCommandIsReady(void) {
	if (rx_buffer_index==20) {
     2b0:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <rx_buffer_index>
     2b4:	84 31       	cpi	r24, 0x14	; 20
     2b6:	59 f4       	brne	.+22     	; 0x2ce <rxBufferCommandIsReady+0x1e>
		if ((rx_buffer_array[0]>'A') && (rx_buffer_array[0]<'Z')) {	// Commands are only cap letters
     2b8:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     2bc:	82 34       	cpi	r24, 0x42	; 66
     2be:	48 f0       	brcs	.+18     	; 0x2d2 <rxBufferCommandIsReady+0x22>
     2c0:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <rx_buffer_array>
			return 1;
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	9a 35       	cpi	r25, 0x5A	; 90
     2c8:	28 f0       	brcs	.+10     	; 0x2d4 <rxBufferCommandIsReady+0x24>
     2ca:	80 e0       	ldi	r24, 0x00	; 0
     2cc:	08 95       	ret
		}
	}
	return 0;
     2ce:	80 e0       	ldi	r24, 0x00	; 0
     2d0:	08 95       	ret
     2d2:	80 e0       	ldi	r24, 0x00	; 0
}
     2d4:	08 95       	ret

000002d6 <rxBufferTimestampIsValid>:
 */
uint8_t rxBufferTimestampIsValid(void) {
	// Check that rx_buffer_array bytes 1-18 are all ASCII numerals ('0' to '9')
	// This check can be improved in future.
	for (uint8_t i=1; i<15; i++) { // Check timestamp section of command string
		if ((rx_buffer_array[i] < '0') || (rx_buffer_array[i] > '9')) {
     2d6:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rx_buffer_array+0x1>
     2da:	80 33       	cpi	r24, 0x30	; 48
     2dc:	08 f1       	brcs	.+66     	; 0x320 <rxBufferTimestampIsValid+0x4a>
     2de:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rx_buffer_array+0x1>
     2e2:	8a 33       	cpi	r24, 0x3A	; 58
     2e4:	f8 f4       	brcc	.+62     	; 0x324 <rxBufferTimestampIsValid+0x4e>
     2e6:	82 e0       	ldi	r24, 0x02	; 2
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	fc 01       	movw	r30, r24
     2ec:	e4 5f       	subi	r30, 0xF4	; 244
     2ee:	fe 4f       	sbci	r31, 0xFE	; 254
     2f0:	20 81       	ld	r18, Z
     2f2:	20 33       	cpi	r18, 0x30	; 48
     2f4:	c8 f0       	brcs	.+50     	; 0x328 <rxBufferTimestampIsValid+0x52>
     2f6:	fc 01       	movw	r30, r24
     2f8:	e4 5f       	subi	r30, 0xF4	; 244
     2fa:	fe 4f       	sbci	r31, 0xFE	; 254
     2fc:	20 81       	ld	r18, Z
     2fe:	2a 33       	cpi	r18, 0x3A	; 58
     300:	a8 f4       	brcc	.+42     	; 0x32c <rxBufferTimestampIsValid+0x56>
     302:	01 96       	adiw	r24, 0x01	; 1
 * always at the same location in the array.
 */
uint8_t rxBufferTimestampIsValid(void) {
	// Check that rx_buffer_array bytes 1-18 are all ASCII numerals ('0' to '9')
	// This check can be improved in future.
	for (uint8_t i=1; i<15; i++) { // Check timestamp section of command string
     304:	8f 30       	cpi	r24, 0x0F	; 15
     306:	91 05       	cpc	r25, r1
     308:	81 f7       	brne	.-32     	; 0x2ea <rxBufferTimestampIsValid+0x14>
		if ((rx_buffer_array[i] < '0') || (rx_buffer_array[i] > '9')) {
			return 0;
		}
	}
	if ((rx_buffer_array[15]!='A') && (rx_buffer_array[15]!='L')) {
     30a:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <rx_buffer_array+0xf>
     30e:	81 34       	cpi	r24, 0x41	; 65
     310:	79 f0       	breq	.+30     	; 0x330 <rxBufferTimestampIsValid+0x5a>
     312:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <rx_buffer_array+0xf>
uint8_t rxBufferTimestampIsValid(void) {
	// Check that rx_buffer_array bytes 1-18 are all ASCII numerals ('0' to '9')
	// This check can be improved in future.
	for (uint8_t i=1; i<15; i++) { // Check timestamp section of command string
		if ((rx_buffer_array[i] < '0') || (rx_buffer_array[i] > '9')) {
			return 0;
     316:	81 e0       	ldi	r24, 0x01	; 1
     318:	9c 34       	cpi	r25, 0x4C	; 76
     31a:	59 f0       	breq	.+22     	; 0x332 <rxBufferTimestampIsValid+0x5c>
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	08 95       	ret
     320:	80 e0       	ldi	r24, 0x00	; 0
     322:	08 95       	ret
     324:	80 e0       	ldi	r24, 0x00	; 0
     326:	08 95       	ret
     328:	80 e0       	ldi	r24, 0x00	; 0
     32a:	08 95       	ret
     32c:	80 e0       	ldi	r24, 0x00	; 0
     32e:	08 95       	ret
		}
	}
	if ((rx_buffer_array[15]!='A') && (rx_buffer_array[15]!='L')) {
		return 0;
	}
	return 1;
     330:	81 e0       	ldi	r24, 0x01	; 1
}
     332:	08 95       	ret

00000334 <hostCommandReceive>:

/*
 * Send host a string of info and receive a command.
 */
void hostCommandReceive(void) {
     334:	0f 93       	push	r16
     336:	1f 93       	push	r17
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
	// Send logger info string (4 bytes of model, 3 bytes of MCU ID (why?), 10 bytes of MCU serial number (OK), 2 bytes of firmware CRC, 6 status-dependent bytes.
	logger_battery_level = adcReadVoltage();
     33c:	0e 94 a0 00 	call	0x140	; 0x140 <adcReadVoltage>
     340:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <logger_battery_level+0x1>
     344:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <logger_battery_level>
	rxBufferClear();									// Clear rx_buffer_array and rx_buffer_index.
     348:	0e 94 36 01 	call	0x26c	; 0x26c <rxBufferClear>
	uartEnable();										// Enable uart module.
     34c:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <uartEnable>
	uartRxInterruptEnable();							// Enable RX receive interrupt.
     350:	0e 94 00 08 	call	0x1000	; 0x1000 <uartRxInterruptEnable>

	uartSendString("TL01");							// 4 bytes of system model.
     354:	80 e0       	ldi	r24, 0x00	; 0
     356:	91 e0       	ldi	r25, 0x01	; 1
     358:	0e 94 1c 08 	call	0x1038	; 0x1038 <uartSendString>
     35c:	cd e2       	ldi	r28, 0x2D	; 45
     35e:	d1 e0       	ldi	r29, 0x01	; 1
     360:	07 e3       	ldi	r16, 0x37	; 55
     362:	11 e0       	ldi	r17, 0x01	; 1
	for (uint8_t i=0; i<10; i++) {
		uartSendByte(mcu_serial_number[i]);				// 10 bytes of mcu serial number
     364:	89 91       	ld	r24, Y+
     366:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
	rxBufferClear();									// Clear rx_buffer_array and rx_buffer_index.
	uartEnable();										// Enable uart module.
	uartRxInterruptEnable();							// Enable RX receive interrupt.

	uartSendString("TL01");							// 4 bytes of system model.
	for (uint8_t i=0; i<10; i++) {
     36a:	c0 17       	cp	r28, r16
     36c:	d1 07       	cpc	r29, r17
     36e:	d1 f7       	brne	.-12     	; 0x364 <hostCommandReceive+0x30>
		uartSendByte(mcu_serial_number[i]);				// 10 bytes of mcu serial number
	}
	uartSendWord(systemLabelGet());					// 2 bytes of local serial.
     370:	0e 94 de 06 	call	0xdbc	; 0xdbc <systemLabelGet>
     374:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
	uartSendByte(FIRMWARE_GET_VERSION);					// 1 byte of firmware version
     378:	83 e0       	ldi	r24, 0x03	; 3
     37a:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
	uartSendWord(mcu_firmware_crc16_xmodem);			// 2 bytes of firmware CRC16-xmodem
     37e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <mcu_firmware_crc16_xmodem>
     382:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <mcu_firmware_crc16_xmodem+0x1>
     386:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
	uartSendWord(logger_battery_level);					// 2 bytes of battery level or 0 if not available
     38a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <logger_battery_level>
     38e:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <logger_battery_level+0x1>
     392:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
	uartSendWord(errorGetFlags());						// 2 bytes of error flags (0x0000 for no errors)
     396:	0e 94 d6 00 	call	0x1ac	; 0x1ac <errorGetFlags>
     39a:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
	uartSendWord(0x0000);								// 2 bytes reserved for future use
     39e:	80 e0       	ldi	r24, 0x00	; 0
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
	// Hereon depends on status. Work on this.
	uartSendByte(logger_mode);						// Status: [I]dle, [L]ogging, [H]olding, [D]ownloaded.
     3a6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     3aa:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
	if (logger_mode=='L') {
     3ae:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     3b2:	8c 34       	cpi	r24, 0x4C	; 76
     3b4:	c9 f4       	brne	.+50     	; 0x3e8 <hostCommandReceive+0xb4>
		uartSendWord(logger_memory_location);			// 2 bytes of data length (bytes, including header)
     3b6:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     3ba:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     3be:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(logger_countdown);					// 2 bytes of logger countdown (deferral)
     3c2:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <logger_countdown>
     3c6:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <logger_countdown+0x1>
     3ca:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(logger_eightseconds_count);		// 2 bytes of current eightseconds count.
     3ce:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <logger_eightseconds_count>
     3d2:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <logger_eightseconds_count+0x1>
     3d6:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(logger_interval);					// 2 bytes of logger interval.		
     3da:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <logger_interval>
     3de:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <logger_interval+0x1>
     3e2:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
     3e6:	38 c0       	rjmp	.+112    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	} else if (logger_mode=='H') {
     3e8:	88 34       	cpi	r24, 0x48	; 72
     3ea:	99 f4       	brne	.+38     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
		uartSendWord(logger_memory_location);			// 2 bytes of data length (bytes, including header)
     3ec:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     3f0:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     3f4:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes of data CRC
     3f8:	80 e0       	ldi	r24, 0x00	; 0
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     400:	80 e0       	ldi	r24, 0x00	; 0
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     408:	80 e0       	ldi	r24, 0x00	; 0
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
     410:	23 c0       	rjmp	.+70     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	} else if (logger_mode=='I') {
     412:	89 34       	cpi	r24, 0x49	; 73
     414:	89 f4       	brne	.+34     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     416:	80 e0       	ldi	r24, 0x00	; 0
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     41e:	80 e0       	ldi	r24, 0x00	; 0
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
     436:	10 c0       	rjmp	.+32     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	} else {
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     438:	80 e0       	ldi	r24, 0x00	; 0
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     440:	80 e0       	ldi	r24, 0x00	; 0
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     448:	80 e0       	ldi	r24, 0x00	; 0
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     450:	80 e0       	ldi	r24, 0x00	; 0
     452:	90 e0       	ldi	r25, 0x00	; 0
     454:	0e 94 12 08 	call	0x1024	; 0x1024 <uartSendWord>
     458:	2f ef       	ldi	r18, 0xFF	; 255
     45a:	80 e7       	ldi	r24, 0x70	; 112
     45c:	92 e0       	ldi	r25, 0x02	; 2
     45e:	21 50       	subi	r18, 0x01	; 1
     460:	80 40       	sbci	r24, 0x00	; 0
     462:	90 40       	sbci	r25, 0x00	; 0
     464:	e1 f7       	brne	.-8      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     466:	00 c0       	rjmp	.+0      	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
     468:	00 00       	nop
	}

	_delay_ms(RX_RECEIVE_TIMEOUT);		// Wait for command string to arrive at rx_buffer_array via RX ISR.
										// Delay instead of polling or counting bytes prevents lock-down.
	uartDisable();						// End of command string receival. Shut the uart module down.
     46a:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <uartDisable>
	
	if (rxBufferCommandIsReady()) {
     46e:	0e 94 58 01 	call	0x2b0	; 0x2b0 <rxBufferCommandIsReady>
     472:	88 23       	and	r24, r24
     474:	09 f4       	brne	.+2      	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
     476:	29 c1       	rjmp	.+594    	; 0x6ca <__LOCK_REGION_LENGTH__+0x2ca>
		// Commands applicable to all modes
		if (rx_buffer_array[0] == 'N') {
     478:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     47c:	8e 34       	cpi	r24, 0x4E	; 78
     47e:	09 f4       	brne	.+2      	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
     480:	28 c1       	rjmp	.+592    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			; // Do nothing
		} else if (rx_buffer_array[0] == 'X') {
     482:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     486:	88 35       	cpi	r24, 0x58	; 88
     488:	41 f4       	brne	.+16     	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
			if (rxBufferIsAllZeros()) {
     48a:	0e 94 43 01 	call	0x286	; 0x286 <rxBufferIsAllZeros>
     48e:	88 23       	and	r24, r24
     490:	09 f4       	brne	.+2      	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
     492:	1f c1       	rjmp	.+574    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				errorClearAll();
     494:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <errorClearAll>
     498:	1c c1       	rjmp	.+568    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'E') {
     49a:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     49e:	85 34       	cpi	r24, 0x45	; 69
     4a0:	09 f0       	breq	.+2      	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
     4a2:	78 c0       	rjmp	.+240    	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
			if (logger_mode=='L' && rxBufferTimestampIsValid()) {
     4a4:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     4a8:	8c 34       	cpi	r24, 0x4C	; 76
     4aa:	09 f0       	breq	.+2      	; 0x4ae <__LOCK_REGION_LENGTH__+0xae>
     4ac:	12 c1       	rjmp	.+548    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
     4ae:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <rxBufferTimestampIsValid>
     4b2:	88 23       	and	r24, r24
     4b4:	09 f4       	brne	.+2      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
     4b6:	0d c1       	rjmp	.+538    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				/*
				 * TODO: Why doesn't this code put memory back to ultra-deep power down?
				 */
				spiEnable();
     4b8:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
				// Write Data CRC to memory (2 bytes)
				memoryWriteByte(logger_memory_location, 'C');
     4bc:	63 e4       	ldi	r22, 0x43	; 67
     4be:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4c2:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     4c6:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     4ca:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4ce:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     4d2:	01 96       	adiw	r24, 0x01	; 1
     4d4:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     4d8:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'C');
     4dc:	63 e4       	ldi	r22, 0x43	; 67
     4de:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     4e2:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4e6:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     4ea:	01 96       	adiw	r24, 0x01	; 1
     4ec:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     4f0:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				// Write number of records to memory (2 bytes)
				memoryWriteByte(logger_memory_location, 'N');
     4f4:	6e e4       	ldi	r22, 0x4E	; 78
     4f6:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     4fa:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4fe:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     502:	01 96       	adiw	r24, 0x01	; 1
     504:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     508:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'N');
     50c:	6e e4       	ldi	r22, 0x4E	; 78
     50e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     512:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     516:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     51a:	01 96       	adiw	r24, 0x01	; 1
     51c:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     520:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				// Append rx_buffer_array bytes 
				memoryWriteArray(logger_memory_location, (uint8_t *) &rx_buffer_array[1], 15);
     524:	4f e0       	ldi	r20, 0x0F	; 15
     526:	6d e0       	ldi	r22, 0x0D	; 13
     528:	71 e0       	ldi	r23, 0x01	; 1
     52a:	0e 94 88 05 	call	0xb10	; 0xb10 <memoryWriteArray>
				logger_memory_location += 15;
     52e:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     532:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     536:	0f 96       	adiw	r24, 0x0f	; 15
     538:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     53c:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 0x00);
     540:	60 e0       	ldi	r22, 0x00	; 0
     542:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     546:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     54a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     54e:	01 96       	adiw	r24, 0x01	; 1
     550:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     554:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'C');
     558:	63 e4       	ldi	r22, 0x43	; 67
     55a:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     55e:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     562:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     566:	01 96       	adiw	r24, 0x01	; 1
     568:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     56c:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'C');
     570:	63 e4       	ldi	r22, 0x43	; 67
     572:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
				logger_memory_location++;
     576:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     57a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     57e:	01 96       	adiw	r24, 0x01	; 1
     580:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     584:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				spiDisable();
     588:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
				// Also set status/mode to 'H'
				logger_mode = 'H';
     58c:	88 e4       	ldi	r24, 0x48	; 72
     58e:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     592:	9f c0       	rjmp	.+318    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'D') {
     594:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     598:	84 34       	cpi	r24, 0x44	; 68
     59a:	f1 f4       	brne	.+60     	; 0x5d8 <__LOCK_REGION_LENGTH__+0x1d8>
			if (rxBufferIsAllZeros()) {
     59c:	0e 94 43 01 	call	0x286	; 0x286 <rxBufferIsAllZeros>
     5a0:	88 23       	and	r24, r24
     5a2:	09 f4       	brne	.+2      	; 0x5a6 <__LOCK_REGION_LENGTH__+0x1a6>
     5a4:	96 c0       	rjmp	.+300    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				if (logger_mode=='I' /*DEBUG*/ || logger_mode=='L' || logger_mode=='H' || logger_mode=='D')	// Modify
     5a6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     5aa:	98 eb       	ldi	r25, 0xB8	; 184
     5ac:	98 0f       	add	r25, r24
     5ae:	92 30       	cpi	r25, 0x02	; 2
     5b0:	20 f0       	brcs	.+8      	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
     5b2:	87 7f       	andi	r24, 0xF7	; 247
     5b4:	84 34       	cpi	r24, 0x44	; 68
     5b6:	09 f0       	breq	.+2      	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
     5b8:	8c c0       	rjmp	.+280    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
					memoryDumpUpto(logger_memory_location);	// Stream out memory bytes, byte per byte, from 0 to logger_memory_location.
     5ba:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     5be:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     5c2:	0e 94 be 05 	call	0xb7c	; 0xb7c <memoryDumpUpto>
				if (logger_mode=='H')
     5c6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     5ca:	88 34       	cpi	r24, 0x48	; 72
     5cc:	09 f0       	breq	.+2      	; 0x5d0 <__LOCK_REGION_LENGTH__+0x1d0>
     5ce:	81 c0       	rjmp	.+258    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
					logger_mode='D';
     5d0:	84 e4       	ldi	r24, 0x44	; 68
     5d2:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     5d6:	7d c0       	rjmp	.+250    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'C') { // Something in here gets stuck
     5d8:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     5dc:	83 34       	cpi	r24, 0x43	; 67
     5de:	c1 f4       	brne	.+48     	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
			if (logger_mode=='D' && rxBufferIsAllZeros()) {
     5e0:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     5e4:	84 34       	cpi	r24, 0x44	; 68
     5e6:	09 f0       	breq	.+2      	; 0x5ea <__LOCK_REGION_LENGTH__+0x1ea>
     5e8:	74 c0       	rjmp	.+232    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
     5ea:	0e 94 43 01 	call	0x286	; 0x286 <rxBufferIsAllZeros>
     5ee:	88 23       	and	r24, r24
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <__LOCK_REGION_LENGTH__+0x1f4>
     5f2:	6f c0       	rjmp	.+222    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				/*
				 * TODO: Why doesn't this code put memory back to ultra-deep power down?
				 */
				spiEnable();
     5f4:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
				memoryEraseChip();	//Clear memory
     5f8:	0e 94 50 06 	call	0xca0	; 0xca0 <memoryEraseChip>
				spiDisable();
     5fc:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
				logger_mode = 'I';
     600:	89 e4       	ldi	r24, 0x49	; 73
     602:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
				logger_memory_location = 0;		// Rewind to 0
     606:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <logger_memory_location+0x1>
     60a:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <logger_memory_location>
     60e:	61 c0       	rjmp	.+194    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'U') {
     610:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     614:	85 35       	cpi	r24, 0x55	; 85
     616:	09 f4       	brne	.+2      	; 0x61a <__LOCK_REGION_LENGTH__+0x21a>
     618:	5c c0       	rjmp	.+184    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			;// Do a firmware update. Here, just reset device.
		} else if (rx_buffer_array[0] == 'B') {
     61a:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     61e:	82 34       	cpi	r24, 0x42	; 66
     620:	09 f0       	breq	.+2      	; 0x624 <__LOCK_REGION_LENGTH__+0x224>
     622:	44 c0       	rjmp	.+136    	; 0x6ac <__LOCK_REGION_LENGTH__+0x2ac>
			if (logger_mode=='I' && rxBufferTimestampIsValid()) {
     624:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     628:	89 34       	cpi	r24, 0x49	; 73
     62a:	09 f0       	breq	.+2      	; 0x62e <__LOCK_REGION_LENGTH__+0x22e>
     62c:	52 c0       	rjmp	.+164    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
     62e:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <rxBufferTimestampIsValid>
     632:	88 23       	and	r24, r24
     634:	09 f4       	brne	.+2      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
     636:	4d c0       	rjmp	.+154    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
					logger_countdown = rx_buffer_array[16];
     638:	ec e0       	ldi	r30, 0x0C	; 12
     63a:	f1 e0       	ldi	r31, 0x01	; 1
     63c:	20 89       	ldd	r18, Z+16	; 0x10
					logger_countdown <<= 8;
					logger_countdown |= rx_buffer_array[17];
     63e:	81 89       	ldd	r24, Z+17	; 0x11
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	92 2b       	or	r25, r18
     644:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <logger_countdown+0x1>
     648:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <logger_countdown>
					logger_interval = rx_buffer_array[18];
     64c:	22 89       	ldd	r18, Z+18	; 0x12
					logger_interval <<= 8;
					logger_interval |= rx_buffer_array[19];
     64e:	83 89       	ldd	r24, Z+19	; 0x13
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	92 2b       	or	r25, r18
     654:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <logger_interval+0x1>
     658:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <logger_interval>
					// Copy format version (0x01), and rx_buffer_array 1-18 to first 22 bytes in EEPROM.
					/*
					 * TODO: Why doesn't this code put memory back to ultra-deep power down?
					 */
					spiEnable();
     65c:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
					memoryWriteByte(0x0000, 0x01);						// Format version
     660:	61 e0       	ldi	r22, 0x01	; 1
     662:	80 e0       	ldi	r24, 0x00	; 0
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
					memoryWriteArray(0x0001, (uint8_t *) &rx_buffer_array[1], 19);	// Copy timestamp, source, countdown, and interval to memory array.
     66a:	43 e1       	ldi	r20, 0x13	; 19
     66c:	6d e0       	ldi	r22, 0x0D	; 13
     66e:	71 e0       	ldi	r23, 0x01	; 1
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	0e 94 88 05 	call	0xb10	; 0xb10 <memoryWriteArray>
					memoryWriteByte(0x0014, 'C');	// Memory address 20 (to be CRC MSB)
     678:	63 e4       	ldi	r22, 0x43	; 67
     67a:	84 e1       	ldi	r24, 0x14	; 20
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
					memoryWriteByte(0x0015, 'C');	// Memory address 21 (to be CRC LSB)
     682:	63 e4       	ldi	r22, 0x43	; 67
     684:	85 e1       	ldi	r24, 0x15	; 21
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	0e 94 50 05 	call	0xaa0	; 0xaa0 <memoryWriteByte>
					spiDisable();
     68c:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
					logger_memory_location = 22;				// For next (first) temperature log
     690:	86 e1       	ldi	r24, 0x16	; 22
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     698:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
					logger_mode = 'L';							// Set logger_status to 'L'
     69c:	8c e4       	ldi	r24, 0x4C	; 76
     69e:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
					logger_eightseconds_count = 0;				// Reset eightseconds counter.
     6a2:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <logger_eightseconds_count+0x1>
     6a6:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <logger_eightseconds_count>
     6aa:	13 c0       	rjmp	.+38     	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			} 
		} else if (rx_buffer_array[0] == 'S') {		// Set logger label number.
     6ac:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     6b0:	83 35       	cpi	r24, 0x53	; 83
     6b2:	79 f4       	brne	.+30     	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			if (rx_buffer_array[2]) {	// 2nd byte must have a value. 1st can have a value or be 0.
     6b4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <rx_buffer_array+0x2>
     6b8:	88 23       	and	r24, r24
     6ba:	59 f0       	breq	.+22     	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				systemLabelWrite(rx_buffer_array[1], rx_buffer_array[2]);
     6bc:	ec e0       	ldi	r30, 0x0C	; 12
     6be:	f1 e0       	ldi	r31, 0x01	; 1
     6c0:	62 81       	ldd	r22, Z+2	; 0x02
     6c2:	81 81       	ldd	r24, Z+1	; 0x01
     6c4:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <systemLabelWrite>
     6c8:	04 c0       	rjmp	.+8      	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		}
	} else {  // Logger didn't receive complete command
        errorSetFlag(ERROR_FLAG_COMMAND_ERR);
     6ca:	84 e0       	ldi	r24, 0x04	; 4
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	0e 94 bf 00 	call	0x17e	; 0x17e <errorSetFlag>
    }
}
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	1f 91       	pop	r17
     6d8:	0f 91       	pop	r16
     6da:	08 95       	ret

000006dc <main>:
/*
 * MAIN function, consists of initialization code and an eternal while(1) loop.
 */
int main(void) {
	// Initialize the system. So many things!
	MCUSR = 0;
     6dc:	14 be       	out	0x34, r1	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	a8 95       	wdr
     6e4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     6e8:	88 61       	ori	r24, 0x18	; 24
     6ea:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     6ee:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     6f2:	0f be       	out	0x3f, r0	; 63
	wdt_disable();			// Disable watchdog timer, in case this was preserved after soft-reset.
	// Disable brown-out detector in sleep mode.
	MCUCR |= (1<<BODSE)|(1<<BODS);
     6f4:	85 b7       	in	r24, 0x35	; 53
     6f6:	80 66       	ori	r24, 0x60	; 96
     6f8:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1<<BODS);
     6fa:	85 b7       	in	r24, 0x35	; 53
     6fc:	80 64       	ori	r24, 0x40	; 64
     6fe:	85 bf       	out	0x35, r24	; 53
	MCUCR &= ~(1<<BODSE);
     700:	85 b7       	in	r24, 0x35	; 53
     702:	8f 7d       	andi	r24, 0xDF	; 223
     704:	85 bf       	out	0x35, r24	; 53

	// Disable ADC
	ADCSRA &= ~(1<<ADEN);					// Disable ADC, stops the ADC clock.
     706:	ea e7       	ldi	r30, 0x7A	; 122
     708:	f0 e0       	ldi	r31, 0x00	; 0
     70a:	80 81       	ld	r24, Z
     70c:	8f 77       	andi	r24, 0x7F	; 127
     70e:	80 83       	st	Z, r24

	// TODO: Disable watchdog timer (Fuse FUSE_WDTON, defaults to ...) Also WDTCSR
	// TODO: Disconnect the bandgap reference from the Analog Comparator (clear the ACBG bit in	ACSR (ACSR.ACBG)).
	ACSR |= (1<<ACD);						// Disable analog comparator (set to disable).
     710:	80 b7       	in	r24, 0x30	; 48
     712:	80 68       	ori	r24, 0x80	; 128
     714:	80 bf       	out	0x30, r24	; 48

	PRR0 |= (1<<PRTWI0)|(1<<PRTIM2)|(1<<PRTIM0)|(1<<PRUSART1)|(1<<PRTIM1)|(1<<PRSPI0)|(1<<PRUSART0)|(1<<PRADC);
     716:	c4 e6       	ldi	r28, 0x64	; 100
     718:	d0 e0       	ldi	r29, 0x00	; 0
     71a:	88 81       	ld	r24, Y
     71c:	8f ef       	ldi	r24, 0xFF	; 255
     71e:	88 83       	st	Y, r24
	PRR1 |= (1<<PRTWI1)|(1<<PRPTC)|(1<<PRTIM4)|(1<<PRSPI1)|(1<<PRTIM3);
     720:	e5 e6       	ldi	r30, 0x65	; 101
     722:	f0 e0       	ldi	r31, 0x00	; 0
     724:	90 81       	ld	r25, Z
     726:	9d 63       	ori	r25, 0x3D	; 61
     728:	90 83       	st	Z, r25
	//SMCR &= ~((1<<SM2)|(1<<SM0));
	//SMCR |= (1<<SM1);

	// Set all ports to input and high before initializing modules that may override these as necessary.
	// Turn all unused pins into inputs with pull-ups.
	DDRB  = 0x00;
     72a:	14 b8       	out	0x04, r1	; 4
	PORTB = 0xFF;
     72c:	85 b9       	out	0x05, r24	; 5
	DDRC  &= ~((1<<DDRC0)|(1<<DDRC1)|(1<<DDRC2)|(1<<DDRC3)|(1<<DDRC4)|(1<<DDRC5)|(1<<DDRC6));		// Port C is 7 bits (0-6).
     72e:	97 b1       	in	r25, 0x07	; 7
     730:	90 78       	andi	r25, 0x80	; 128
     732:	97 b9       	out	0x07, r25	; 7
	PORTC |= ((1<<PORTC0)|(1<<PORTC1)|(1<<PORTC2)|(1<<PORTC3)|(1<<PORTC4)|(1<<PORTC5)|(1<<PORTC6));
     734:	98 b1       	in	r25, 0x08	; 8
     736:	9f 67       	ori	r25, 0x7F	; 127
     738:	98 b9       	out	0x08, r25	; 8
	DDRD  = 0x00;
     73a:	1a b8       	out	0x0a, r1	; 10
	PORTD = 0xFF;
     73c:	8b b9       	out	0x0b, r24	; 11
	DDRE  &= ~((1<<DDRE0)|(1<<DDRE1)|(1<<DDRE3));
     73e:	8d b1       	in	r24, 0x0d	; 13
     740:	84 7f       	andi	r24, 0xF4	; 244
     742:	8d b9       	out	0x0d, r24	; 13
	PORTE |= ((1<<PORTE0)|(1<<PORTE1)|(1<<PORTE3));
     744:	8e b1       	in	r24, 0x0e	; 14
     746:	8b 60       	ori	r24, 0x0B	; 11
     748:	8e b9       	out	0x0e, r24	; 14
	DDRE |= (1<<DDRE2);
     74a:	6a 9a       	sbi	0x0d, 2	; 13
	PORTE &= ~(1<<PORTE2);					// Stays here
     74c:	72 98       	cbi	0x0e, 2	; 14
	
	
	//Digital input buffers can be disabled by writing to the Digital Input Disable Registers (DIDR0 for ADC, DIDR1 for AC). (found at http://microchipdeveloper.com/8avr:avrsleep)
	//If the On-chip debug system is enabled by the DWEN Fuse and the chip enters sleep mode, the main clock source is enabled and hence always consumes power. In the deeper sleep modes, this will contribute significantly to the total current consumption.

	errorInitFlags();
     74e:	0e 94 ba 00 	call	0x174	; 0x174 <errorInitFlags>
	indicatorInitialize();
     752:	0e 94 db 00 	call	0x1b6	; 0x1b6 <indicatorInitialize>
		
	// Start the Real Time Counter. Takes 1000ms+ to allow crystal to stabilize.
	PRR0	&= ~(1<<PRTIM2);								// Clear timer2 bit at power reduction register.
     756:	88 81       	ld	r24, Y
     758:	8f 7b       	andi	r24, 0xBF	; 191
     75a:	88 83       	st	Y, r24
	ASSR	|= (1<<AS2);									// Clock from external crystal.
     75c:	e6 eb       	ldi	r30, 0xB6	; 182
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	80 81       	ld	r24, Z
     762:	80 62       	ori	r24, 0x20	; 32
     764:	80 83       	st	Z, r24
	TCCR2B	|= (1<<CS20)|(1<<CS21)|(1<<CS22);				// Tosc/1024 prescaler = 8sec to overflow.
     766:	e1 eb       	ldi	r30, 0xB1	; 177
     768:	f0 e0       	ldi	r31, 0x00	; 0
     76a:	80 81       	ld	r24, Z
     76c:	87 60       	ori	r24, 0x07	; 7
     76e:	80 83       	st	Z, r24
	TIMSK2	= 0;
     770:	e0 e7       	ldi	r30, 0x70	; 112
     772:	f0 e0       	ldi	r31, 0x00	; 0
     774:	10 82       	st	Z, r1
	TIMSK2	|= (1<<TOIE2);									// Enable overflow interrupt
     776:	80 81       	ld	r24, Z
     778:	81 60       	ori	r24, 0x01	; 1
     77a:	80 83       	st	Z, r24
	//_delay_ms(1000);										// Allow RTC crystal to stabilize (RTC AN p.5).
	TCNT2	= 0;											// Clear counter value.
     77c:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
	sei();	
     780:	78 94       	sei
	
	max30205Init();									// Initialize temperature sensor chip into lowest power consumption.
     782:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <max30205Init>
	
	// Initialize memory chip and set it to low power.
	memoryInitialize();								// Initialize memory chip.
     786:	0e 94 96 06 	call	0xd2c	; 0xd2c <memoryInitialize>
	logger_memory_location = memoryScan();			// Find byte address of first blank word. Should be 0.
     78a:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <memoryScan>
     78e:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     792:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
	memoryUltraDeepPowerDownEnter();				// Place memory chip into lowest power consumption.
     796:	0e 94 69 06 	call	0xcd2	; 0xcd2 <memoryUltraDeepPowerDownEnter>
	
	// Check memory if empty. If not, set logger in 'Holding' mode.
	if (logger_memory_location) {
     79a:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     79e:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     7a2:	89 2b       	or	r24, r25
     7a4:	21 f0       	breq	.+8      	; 0x7ae <main+0xd2>
		logger_mode = 'H';
     7a6:	88 e4       	ldi	r24, 0x48	; 72
     7a8:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     7ac:	da c0       	rjmp	.+436    	; 0x962 <__stack+0x63>
	} else {
		logger_mode = 'I';
     7ae:	89 e4       	ldi	r24, 0x49	; 73
     7b0:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     7b4:	d6 c0       	rjmp	.+428    	; 0x962 <__stack+0x63>
	}


	// Load MCU serial number.
	for (uint8_t i=0; i<10; i++) {
		mcu_serial_number[i] = boot_signature_byte_get(i+14);	// Read signature bytes 14-23
     7b6:	fc 01       	movw	r30, r24
     7b8:	ea 0f       	add	r30, r26
     7ba:	fb 1f       	adc	r31, r27
     7bc:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
     7c0:	e4 91       	lpm	r30, Z
     7c2:	ed 93       	st	X+, r30
		logger_mode = 'I';
	}


	// Load MCU serial number.
	for (uint8_t i=0; i<10; i++) {
     7c4:	4a 17       	cp	r20, r26
     7c6:	5b 07       	cpc	r21, r27
     7c8:	b1 f7       	brne	.-20     	; 0x7b6 <main+0xda>
		mcu_serial_number[i] = boot_signature_byte_get(i+14);	// Read signature bytes 14-23
	}
	systemLabelLoad();
     7ca:	0e 94 c4 06 	call	0xd88	; 0xd88 <systemLabelLoad>
	
	mcu_bootloader_first_byte = systemBootloaderGetAddress();
     7ce:	0e 94 f3 06 	call	0xde6	; 0xde6 <systemBootloaderGetAddress>
     7d2:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <mcu_bootloader_first_byte+0x1>
     7d6:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <mcu_bootloader_first_byte>
	mcu_firmware_available_pages = mcu_bootloader_first_byte / SPM_PAGESIZE;
     7da:	9c 01       	movw	r18, r24
     7dc:	22 0f       	add	r18, r18
     7de:	23 2f       	mov	r18, r19
     7e0:	22 1f       	adc	r18, r18
     7e2:	33 0b       	sbc	r19, r19
     7e4:	31 95       	neg	r19
     7e6:	30 93 2a 01 	sts	0x012A, r19	; 0x80012a <mcu_firmware_available_pages+0x1>
     7ea:	20 93 29 01 	sts	0x0129, r18	; 0x800129 <mcu_firmware_available_pages>

	// Find the last byte of firmware in flash.
	for (uint16_t k=(mcu_bootloader_first_byte-1); k>0; k--) {
     7ee:	fc 01       	movw	r30, r24
     7f0:	31 97       	sbiw	r30, 0x01	; 1
     7f2:	71 f0       	breq	.+28     	; 0x810 <main+0x134>
		if (pgm_read_byte(k) != 0xFF) {
     7f4:	84 91       	lpm	r24, Z
     7f6:	8f 3f       	cpi	r24, 0xFF	; 255
     7f8:	49 f0       	breq	.+18     	; 0x80c <main+0x130>
     7fa:	03 c0       	rjmp	.+6      	; 0x802 <main+0x126>
     7fc:	84 91       	lpm	r24, Z
     7fe:	8f 3f       	cpi	r24, 0xFF	; 255
     800:	29 f0       	breq	.+10     	; 0x80c <main+0x130>
			mcu_firmware_last_byte = k;
     802:	f0 93 23 01 	sts	0x0123, r31	; 0x800123 <mcu_firmware_last_byte+0x1>
     806:	e0 93 22 01 	sts	0x0122, r30	; 0x800122 <mcu_firmware_last_byte>
			break;
     80a:	02 c0       	rjmp	.+4      	; 0x810 <main+0x134>
	
	mcu_bootloader_first_byte = systemBootloaderGetAddress();
	mcu_firmware_available_pages = mcu_bootloader_first_byte / SPM_PAGESIZE;

	// Find the last byte of firmware in flash.
	for (uint16_t k=(mcu_bootloader_first_byte-1); k>0; k--) {
     80c:	31 97       	sbiw	r30, 0x01	; 1
     80e:	b1 f7       	brne	.-20     	; 0x7fc <main+0x120>
		}
	}

	// Calculate firmware xmodem CRC16
	mcu_firmware_crc16_xmodem = 0;
	for (uint16_t i=0; i<=mcu_firmware_last_byte; i++) {
     810:	40 91 22 01 	lds	r20, 0x0122	; 0x800122 <mcu_firmware_last_byte>
     814:	50 91 23 01 	lds	r21, 0x0123	; 0x800123 <mcu_firmware_last_byte+0x1>
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	e0 e0       	ldi	r30, 0x00	; 0
     81e:	f0 e0       	ldi	r31, 0x00	; 0
		mcu_firmware_crc16_xmodem = _crc_xmodem_update(mcu_firmware_crc16_xmodem, pgm_read_byte(i));
     820:	24 91       	lpm	r18, Z
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
     822:	92 27       	eor	r25, r18
     824:	09 2e       	mov	r0, r25
     826:	02 94       	swap	r0
     828:	20 2d       	mov	r18, r0
     82a:	2f 70       	andi	r18, 0x0F	; 15
     82c:	29 27       	eor	r18, r25
     82e:	39 2f       	mov	r19, r25
     830:	30 25       	eor	r19, r0
     832:	33 0f       	add	r19, r19
     834:	30 7e       	andi	r19, 0xE0	; 224
     836:	23 27       	eor	r18, r19
     838:	30 2d       	mov	r19, r0
     83a:	39 27       	eor	r19, r25
     83c:	30 7f       	andi	r19, 0xF0	; 240
     83e:	36 95       	lsr	r19
     840:	09 2e       	mov	r0, r25
     842:	00 0c       	add	r0, r0
     844:	33 1f       	adc	r19, r19
     846:	96 95       	lsr	r25
     848:	96 95       	lsr	r25
     84a:	96 95       	lsr	r25
     84c:	9f 71       	andi	r25, 0x1F	; 31
     84e:	93 27       	eor	r25, r19
     850:	98 27       	eor	r25, r24
     852:	82 2f       	mov	r24, r18
		}
	}

	// Calculate firmware xmodem CRC16
	mcu_firmware_crc16_xmodem = 0;
	for (uint16_t i=0; i<=mcu_firmware_last_byte; i++) {
     854:	31 96       	adiw	r30, 0x01	; 1
     856:	4e 17       	cp	r20, r30
     858:	5f 07       	cpc	r21, r31
     85a:	10 f7       	brcc	.-60     	; 0x820 <main+0x144>
     85c:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <mcu_firmware_crc16_xmodem>
     860:	90 93 3b 01 	sts	0x013B, r25	; 0x80013b <mcu_firmware_crc16_xmodem+0x1>
		mcu_firmware_crc16_xmodem = _crc_xmodem_update(mcu_firmware_crc16_xmodem, pgm_read_byte(i));
	}
	indicatorShortBlink();
     864:	0e 94 de 00 	call	0x1bc	; 0x1bc <indicatorShortBlink>


	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
     868:	83 b7       	in	r24, 0x33	; 51
     86a:	81 7f       	andi	r24, 0xF1	; 241
     86c:	86 60       	ori	r24, 0x06	; 6
     86e:	83 bf       	out	0x33, r24	; 51
			} else if (logger_eightseconds_count<logger_interval) {
					// Do nothing. logger_eightseconds_count is incremented at ISR
			} else {
				if (logger_memory_location < LOGGER_HEADER_SIZE) {	// Wrapped through end of memory? (No way!)
					errorSetFlag(ERROR_FLAG_MEM_ADDRESS_ERR);
					logger_mode = 'H';
     870:	c8 e4       	ldi	r28, 0x48	; 72
	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
	/*******************************************
	*               MAIN LOOP                  *
	*******************************************/
    while (1) {
		sleep_mode();
     872:	83 b7       	in	r24, 0x33	; 51
     874:	81 60       	ori	r24, 0x01	; 1
     876:	83 bf       	out	0x33, r24	; 51
     878:	88 95       	sleep
     87a:	83 b7       	in	r24, 0x33	; 51
     87c:	8e 7f       	andi	r24, 0xFE	; 254
     87e:	83 bf       	out	0x33, r24	; 51
		if (logger_mode == 'L') {
     880:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     884:	8c 34       	cpi	r24, 0x4C	; 76
     886:	09 f0       	breq	.+2      	; 0x88a <main+0x1ae>
     888:	67 c0       	rjmp	.+206    	; 0x958 <__stack+0x59>
			if (logger_countdown>0) {
     88a:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <logger_countdown>
     88e:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <logger_countdown+0x1>
     892:	00 97       	sbiw	r24, 0x00	; 0
     894:	51 f0       	breq	.+20     	; 0x8aa <main+0x1ce>
				logger_countdown--;
     896:	01 97       	sbiw	r24, 0x01	; 1
     898:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <logger_countdown+0x1>
     89c:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <logger_countdown>
				logger_eightseconds_count = 0;
     8a0:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <logger_eightseconds_count+0x1>
     8a4:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <logger_eightseconds_count>
     8a8:	55 c0       	rjmp	.+170    	; 0x954 <__stack+0x55>
			} else if (logger_eightseconds_count<logger_interval) {
     8aa:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <logger_eightseconds_count>
     8ae:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <logger_eightseconds_count+0x1>
     8b2:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <logger_interval>
     8b6:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <logger_interval+0x1>
     8ba:	28 17       	cp	r18, r24
     8bc:	39 07       	cpc	r19, r25
     8be:	08 f4       	brcc	.+2      	; 0x8c2 <main+0x1e6>
     8c0:	49 c0       	rjmp	.+146    	; 0x954 <__stack+0x55>
					// Do nothing. logger_eightseconds_count is incremented at ISR
			} else {
				if (logger_memory_location < LOGGER_HEADER_SIZE) {	// Wrapped through end of memory? (No way!)
     8c2:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     8c6:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     8ca:	46 97       	sbiw	r24, 0x16	; 22
     8cc:	38 f4       	brcc	.+14     	; 0x8dc <main+0x200>
					errorSetFlag(ERROR_FLAG_MEM_ADDRESS_ERR);
     8ce:	85 e0       	ldi	r24, 0x05	; 5
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	0e 94 bf 00 	call	0x17e	; 0x17e <errorSetFlag>
					logger_mode = 'H';
     8d6:	c0 93 37 01 	sts	0x0137, r28	; 0x800137 <logger_mode>
     8da:	3c c0       	rjmp	.+120    	; 0x954 <__stack+0x55>
				} else {
					memoryUltraDeepPowerDownExitBegin();
     8dc:	0e 94 71 06 	call	0xce2	; 0xce2 <memoryUltraDeepPowerDownExitBegin>
					max30205StartOneShot();
     8e0:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <max30205StartOneShot>
     8e4:	2f ef       	ldi	r18, 0xFF	; 255
     8e6:	86 e7       	ldi	r24, 0x76	; 118
     8e8:	91 e0       	ldi	r25, 0x01	; 1
     8ea:	21 50       	subi	r18, 0x01	; 1
     8ec:	80 40       	sbci	r24, 0x00	; 0
     8ee:	90 40       	sbci	r25, 0x00	; 0
     8f0:	e1 f7       	brne	.-8      	; 0x8ea <main+0x20e>
     8f2:	00 c0       	rjmp	.+0      	; 0x8f4 <main+0x218>
     8f4:	00 00       	nop
					_delay_ms(60);										// Wait for MAX30205 to read temperature.
					logger_temperature = max30205ReadTemperature();
     8f6:	0e 94 f5 04 	call	0x9ea	; 0x9ea <max30205ReadTemperature>
     8fa:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <logger_temperature+0x1>
     8fe:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <logger_temperature>
     902:	8f e3       	ldi	r24, 0x3F	; 63
     904:	9c e9       	ldi	r25, 0x9C	; 156
     906:	01 97       	sbiw	r24, 0x01	; 1
     908:	f1 f7       	brne	.-4      	; 0x906 <__stack+0x7>
     90a:	00 c0       	rjmp	.+0      	; 0x90c <__stack+0xd>
     90c:	00 00       	nop
					_delay_ms(20);										// Wait for memory to recover from deep power down.
					spiEnable();
     90e:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
					memoryWriteWord(logger_memory_location, logger_temperature);
     912:	60 91 2b 01 	lds	r22, 0x012B	; 0x80012b <logger_temperature>
     916:	70 91 2c 01 	lds	r23, 0x012C	; 0x80012c <logger_temperature+0x1>
     91a:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     91e:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     922:	0e 94 69 05 	call	0xad2	; 0xad2 <memoryWriteWord>
					spiDisable();
     926:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
					logger_memory_location += 2;
     92a:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     92e:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     932:	02 96       	adiw	r24, 0x02	; 2
     934:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     938:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
					logger_eightseconds_count = 0;
     93c:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <logger_eightseconds_count+0x1>
     940:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <logger_eightseconds_count>
     944:	8f ea       	ldi	r24, 0xAF	; 175
     946:	96 e3       	ldi	r25, 0x36	; 54
     948:	01 97       	sbiw	r24, 0x01	; 1
     94a:	f1 f7       	brne	.-4      	; 0x948 <__stack+0x49>
     94c:	00 c0       	rjmp	.+0      	; 0x94e <__stack+0x4f>
     94e:	00 00       	nop
					_delay_ms(7);	// TODO: Any chance memory write isn't done and pwr down is skipped? 
					memoryUltraDeepPowerDownEnter();
     950:	0e 94 69 06 	call	0xcd2	; 0xcd2 <memoryUltraDeepPowerDownEnter>
				}
			}
			indicatorShortBlink();
     954:	0e 94 de 00 	call	0x1bc	; 0x1bc <indicatorShortBlink>
		} else if (logger_mode=='I') {
			;
		} // End of mode actions if-implemented 'switch'
		
		
		if ( !(PIND & (1<<PIND2))) { // PD2 is down - the uart cable is connected.
     958:	4a 99       	sbic	0x09, 2	; 9
     95a:	8b cf       	rjmp	.-234    	; 0x872 <main+0x196>
			hostCommandReceive();
     95c:	0e 94 9a 01 	call	0x334	; 0x334 <hostCommandReceive>
     960:	88 cf       	rjmp	.-240    	; 0x872 <main+0x196>
     962:	47 e3       	ldi	r20, 0x37	; 55
     964:	51 e0       	ldi	r21, 0x01	; 1


/*
 * MAIN function, consists of initialization code and an eternal while(1) loop.
 */
int main(void) {
     966:	ad e2       	ldi	r26, 0x2D	; 45
     968:	b1 e0       	ldi	r27, 0x01	; 1
	}


	// Load MCU serial number.
	for (uint8_t i=0; i<10; i++) {
		mcu_serial_number[i] = boot_signature_byte_get(i+14);	// Read signature bytes 14-23
     96a:	21 e2       	ldi	r18, 0x21	; 33
     96c:	8e e0       	ldi	r24, 0x0E	; 14
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	8d 52       	subi	r24, 0x2D	; 45
     972:	91 40       	sbci	r25, 0x01	; 1
     974:	20 cf       	rjmp	.-448    	; 0x7b6 <main+0xda>

00000976 <max30205ReadConfig>:
     976:	61 e0       	ldi	r22, 0x01	; 1
     978:	80 e9       	ldi	r24, 0x90	; 144
     97a:	0e 94 81 07 	call	0xf02	; 0xf02 <twiDRead8>
     97e:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
     982:	08 95       	ret

00000984 <max30205SaveConfig>:
     984:	40 91 3c 01 	lds	r20, 0x013C	; 0x80013c <max30205_config>
     988:	61 e0       	ldi	r22, 0x01	; 1
     98a:	80 e9       	ldi	r24, 0x90	; 144
     98c:	0e 94 c3 07 	call	0xf86	; 0xf86 <twiDWrite8>
     990:	08 95       	ret

00000992 <max30205EnterShutdown>:
     992:	0e 94 bb 04 	call	0x976	; 0x976 <max30205ReadConfig>
     996:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <max30205_config>
     99a:	81 60       	ori	r24, 0x01	; 1
     99c:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
     9a0:	0e 94 c2 04 	call	0x984	; 0x984 <max30205SaveConfig>
     9a4:	40 91 3c 01 	lds	r20, 0x013C	; 0x80013c <max30205_config>
     9a8:	61 e0       	ldi	r22, 0x01	; 1
     9aa:	80 e9       	ldi	r24, 0x90	; 144
     9ac:	0e 94 c3 07 	call	0xf86	; 0xf86 <twiDWrite8>
     9b0:	08 95       	ret

000009b2 <max30205Init>:
     9b2:	52 98       	cbi	0x0a, 2	; 10
     9b4:	5a 9a       	sbi	0x0b, 2	; 11
     9b6:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <twiEnable>
     9ba:	0e 94 c9 04 	call	0x992	; 0x992 <max30205EnterShutdown>
     9be:	0e 94 70 07 	call	0xee0	; 0xee0 <twiDisable>
     9c2:	08 95       	ret

000009c4 <max30205StartOneShot>:
     9c4:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <max30205_config>
     9c8:	80 ff       	sbrs	r24, 0
     9ca:	0e c0       	rjmp	.+28     	; 0x9e8 <max30205StartOneShot+0x24>
     9cc:	80 68       	ori	r24, 0x80	; 128
     9ce:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
     9d2:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <twiEnable>
     9d6:	0e 94 c2 04 	call	0x984	; 0x984 <max30205SaveConfig>
     9da:	0e 94 70 07 	call	0xee0	; 0xee0 <twiDisable>
     9de:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <max30205_config>
     9e2:	8f 77       	andi	r24, 0x7F	; 127
     9e4:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
     9e8:	08 95       	ret

000009ea <max30205ReadTemperature>:
     9ea:	cf 93       	push	r28
     9ec:	df 93       	push	r29
     9ee:	0e 94 5b 07 	call	0xeb6	; 0xeb6 <twiEnable>
     9f2:	60 e0       	ldi	r22, 0x00	; 0
     9f4:	80 e9       	ldi	r24, 0x90	; 144
     9f6:	0e 94 95 07 	call	0xf2a	; 0xf2a <twiDRead16>
     9fa:	ec 01       	movw	r28, r24
     9fc:	0e 94 70 07 	call	0xee0	; 0xee0 <twiDisable>
     a00:	ce 01       	movw	r24, r28
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <_memorySingleCommand>:
     a08:	2a 98       	cbi	0x05, 2	; 5
     a0a:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     a0e:	2a 9a       	sbi	0x05, 2	; 5
     a10:	08 95       	ret

00000a12 <_memorySendAddress>:
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	c8 2f       	mov	r28, r24
     a18:	d9 2f       	mov	r29, r25
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     a20:	8d 2f       	mov	r24, r29
     a22:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     a26:	8c 2f       	mov	r24, r28
     a28:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     a2c:	df 91       	pop	r29
     a2e:	cf 91       	pop	r28
     a30:	08 95       	ret

00000a32 <_memoryFlagSet>:
     a32:	21 e0       	ldi	r18, 0x01	; 1
     a34:	30 e0       	ldi	r19, 0x00	; 0
     a36:	02 c0       	rjmp	.+4      	; 0xa3c <_memoryFlagSet+0xa>
     a38:	22 0f       	add	r18, r18
     a3a:	33 1f       	adc	r19, r19
     a3c:	8a 95       	dec	r24
     a3e:	e2 f7       	brpl	.-8      	; 0xa38 <_memoryFlagSet+0x6>
     a40:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <memory_flags>
     a44:	28 2b       	or	r18, r24
     a46:	20 93 c1 01 	sts	0x01C1, r18	; 0x8001c1 <memory_flags>
     a4a:	08 95       	ret

00000a4c <_memoryBusy>:
     a4c:	2a 98       	cbi	0x05, 2	; 5
     a4e:	85 e0       	ldi	r24, 0x05	; 5
     a50:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     a54:	85 e0       	ldi	r24, 0x05	; 5
     a56:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     a5a:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <memory_status_byte_1>
     a5e:	2a 9a       	sbi	0x05, 2	; 5
     a60:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <memory_status_byte_1>
     a64:	81 70       	andi	r24, 0x01	; 1
     a66:	08 95       	ret

00000a68 <_memoryCheckBusy>:
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	c0 e0       	ldi	r28, 0x00	; 0
     a6e:	d0 e0       	ldi	r29, 0x00	; 0
     a70:	05 c0       	rjmp	.+10     	; 0xa7c <_memoryCheckBusy+0x14>
     a72:	21 96       	adiw	r28, 0x01	; 1
     a74:	8a e1       	ldi	r24, 0x1A	; 26
     a76:	8a 95       	dec	r24
     a78:	f1 f7       	brne	.-4      	; 0xa76 <_memoryCheckBusy+0xe>
     a7a:	00 c0       	rjmp	.+0      	; 0xa7c <_memoryCheckBusy+0x14>
     a7c:	0e 94 26 05 	call	0xa4c	; 0xa4c <_memoryBusy>
     a80:	88 23       	and	r24, r24
     a82:	29 f0       	breq	.+10     	; 0xa8e <_memoryCheckBusy+0x26>
     a84:	c8 3e       	cpi	r28, 0xE8	; 232
     a86:	83 e0       	ldi	r24, 0x03	; 3
     a88:	d8 07       	cpc	r29, r24
     a8a:	99 f7       	brne	.-26     	; 0xa72 <_memoryCheckBusy+0xa>
     a8c:	03 c0       	rjmp	.+6      	; 0xa94 <_memoryCheckBusy+0x2c>
     a8e:	c8 3e       	cpi	r28, 0xE8	; 232
     a90:	d3 40       	sbci	r29, 0x03	; 3
     a92:	18 f0       	brcs	.+6      	; 0xa9a <_memoryCheckBusy+0x32>
     a94:	85 e0       	ldi	r24, 0x05	; 5
     a96:	0e 94 19 05 	call	0xa32	; 0xa32 <_memoryFlagSet>
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	08 95       	ret

00000aa0 <memoryWriteByte>:
     aa0:	0f 93       	push	r16
     aa2:	1f 93       	push	r17
     aa4:	cf 93       	push	r28
     aa6:	8c 01       	movw	r16, r24
     aa8:	c6 2f       	mov	r28, r22
     aaa:	0e 94 34 05 	call	0xa68	; 0xa68 <_memoryCheckBusy>
     aae:	86 e0       	ldi	r24, 0x06	; 6
     ab0:	0e 94 04 05 	call	0xa08	; 0xa08 <_memorySingleCommand>
     ab4:	2a 98       	cbi	0x05, 2	; 5
     ab6:	82 e0       	ldi	r24, 0x02	; 2
     ab8:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     abc:	c8 01       	movw	r24, r16
     abe:	0e 94 09 05 	call	0xa12	; 0xa12 <_memorySendAddress>
     ac2:	8c 2f       	mov	r24, r28
     ac4:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     ac8:	2a 9a       	sbi	0x05, 2	; 5
     aca:	cf 91       	pop	r28
     acc:	1f 91       	pop	r17
     ace:	0f 91       	pop	r16
     ad0:	08 95       	ret

00000ad2 <memoryWriteWord>:
     ad2:	0f 93       	push	r16
     ad4:	1f 93       	push	r17
     ad6:	cf 93       	push	r28
     ad8:	df 93       	push	r29
     ada:	8c 01       	movw	r16, r24
     adc:	c6 2f       	mov	r28, r22
     ade:	d7 2f       	mov	r29, r23
     ae0:	0e 94 34 05 	call	0xa68	; 0xa68 <_memoryCheckBusy>
     ae4:	86 e0       	ldi	r24, 0x06	; 6
     ae6:	0e 94 04 05 	call	0xa08	; 0xa08 <_memorySingleCommand>
     aea:	2a 98       	cbi	0x05, 2	; 5
     aec:	82 e0       	ldi	r24, 0x02	; 2
     aee:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     af2:	c8 01       	movw	r24, r16
     af4:	0e 94 09 05 	call	0xa12	; 0xa12 <_memorySendAddress>
     af8:	8d 2f       	mov	r24, r29
     afa:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     afe:	8c 2f       	mov	r24, r28
     b00:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     b04:	2a 9a       	sbi	0x05, 2	; 5
     b06:	df 91       	pop	r29
     b08:	cf 91       	pop	r28
     b0a:	1f 91       	pop	r17
     b0c:	0f 91       	pop	r16
     b0e:	08 95       	ret

00000b10 <memoryWriteArray>:
     b10:	ef 92       	push	r14
     b12:	ff 92       	push	r15
     b14:	0f 93       	push	r16
     b16:	1f 93       	push	r17
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29
     b1c:	ec 01       	movw	r28, r24
     b1e:	7b 01       	movw	r14, r22
     b20:	14 2f       	mov	r17, r20
     b22:	0e 94 34 05 	call	0xa68	; 0xa68 <_memoryCheckBusy>
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	91 e0       	ldi	r25, 0x01	; 1
     b2a:	81 1b       	sub	r24, r17
     b2c:	91 09       	sbc	r25, r1
     b2e:	9e 01       	movw	r18, r28
     b30:	33 27       	eor	r19, r19
     b32:	82 17       	cp	r24, r18
     b34:	93 07       	cpc	r25, r19
     b36:	dc f0       	brlt	.+54     	; 0xb6e <memoryWriteArray+0x5e>
     b38:	86 e0       	ldi	r24, 0x06	; 6
     b3a:	0e 94 04 05 	call	0xa08	; 0xa08 <_memorySingleCommand>
     b3e:	2a 98       	cbi	0x05, 2	; 5
     b40:	82 e0       	ldi	r24, 0x02	; 2
     b42:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     b46:	ce 01       	movw	r24, r28
     b48:	0e 94 09 05 	call	0xa12	; 0xa12 <_memorySendAddress>
     b4c:	11 23       	and	r17, r17
     b4e:	71 f0       	breq	.+28     	; 0xb6c <memoryWriteArray+0x5c>
     b50:	e7 01       	movw	r28, r14
     b52:	11 50       	subi	r17, 0x01	; 1
     b54:	01 2f       	mov	r16, r17
     b56:	10 e0       	ldi	r17, 0x00	; 0
     b58:	0f 5f       	subi	r16, 0xFF	; 255
     b5a:	1f 4f       	sbci	r17, 0xFF	; 255
     b5c:	0e 0d       	add	r16, r14
     b5e:	1f 1d       	adc	r17, r15
     b60:	89 91       	ld	r24, Y+
     b62:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     b66:	c0 17       	cp	r28, r16
     b68:	d1 07       	cpc	r29, r17
     b6a:	d1 f7       	brne	.-12     	; 0xb60 <memoryWriteArray+0x50>
     b6c:	2a 9a       	sbi	0x05, 2	; 5
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	1f 91       	pop	r17
     b74:	0f 91       	pop	r16
     b76:	ff 90       	pop	r15
     b78:	ef 90       	pop	r14
     b7a:	08 95       	ret

00000b7c <memoryDumpUpto>:
     b7c:	0f 93       	push	r16
     b7e:	1f 93       	push	r17
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	8c 01       	movw	r16, r24
     b86:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
     b8a:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <uartEnable>
     b8e:	0e 94 34 05 	call	0xa68	; 0xa68 <_memoryCheckBusy>
     b92:	2a 98       	cbi	0x05, 2	; 5
     b94:	83 e0       	ldi	r24, 0x03	; 3
     b96:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     b9a:	80 e0       	ldi	r24, 0x00	; 0
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	0e 94 09 05 	call	0xa12	; 0xa12 <_memorySendAddress>
     ba2:	01 15       	cp	r16, r1
     ba4:	11 05       	cpc	r17, r1
     ba6:	51 f4       	brne	.+20     	; 0xbbc <memoryDumpUpto+0x40>
     ba8:	c0 e0       	ldi	r28, 0x00	; 0
     baa:	d0 e0       	ldi	r29, 0x00	; 0
     bac:	80 e0       	ldi	r24, 0x00	; 0
     bae:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     bb2:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
     bb6:	21 97       	sbiw	r28, 0x01	; 1
     bb8:	c9 f7       	brne	.-14     	; 0xbac <memoryDumpUpto+0x30>
     bba:	0b c0       	rjmp	.+22     	; 0xbd2 <memoryDumpUpto+0x56>
     bbc:	c0 e0       	ldi	r28, 0x00	; 0
     bbe:	d0 e0       	ldi	r29, 0x00	; 0
     bc0:	80 e0       	ldi	r24, 0x00	; 0
     bc2:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     bc6:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
     bca:	21 96       	adiw	r28, 0x01	; 1
     bcc:	0c 17       	cp	r16, r28
     bce:	1d 07       	cpc	r17, r29
     bd0:	b9 f7       	brne	.-18     	; 0xbc0 <memoryDumpUpto+0x44>
     bd2:	2a 9a       	sbi	0x05, 2	; 5
     bd4:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
     bd8:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <uartDisable>
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	1f 91       	pop	r17
     be2:	0f 91       	pop	r16
     be4:	08 95       	ret

00000be6 <memoryScan>:
     be6:	ff 92       	push	r15
     be8:	0f 93       	push	r16
     bea:	1f 93       	push	r17
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	cd b7       	in	r28, 0x3d	; 61
     bf2:	de b7       	in	r29, 0x3e	; 62
     bf4:	cf 5f       	subi	r28, 0xFF	; 255
     bf6:	d1 09       	sbc	r29, r1
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	de bf       	out	0x3e, r29	; 62
     bfe:	0f be       	out	0x3f, r0	; 63
     c00:	cd bf       	out	0x3d, r28	; 61
     c02:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
     c06:	0f ef       	ldi	r16, 0xFF	; 255
     c08:	ff 24       	eor	r15, r15
     c0a:	fa 94       	dec	r15
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <memoryScan+0x2a>
     c0e:	08 2f       	mov	r16, r24
     c10:	2a 98       	cbi	0x05, 2	; 5
     c12:	83 e0       	ldi	r24, 0x03	; 3
     c14:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     c18:	80 e0       	ldi	r24, 0x00	; 0
     c1a:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     c1e:	80 2f       	mov	r24, r16
     c20:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     c24:	80 e0       	ldi	r24, 0x00	; 0
     c26:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     c2a:	10 e0       	ldi	r17, 0x00	; 0
     c2c:	80 e0       	ldi	r24, 0x00	; 0
     c2e:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     c32:	e1 e0       	ldi	r30, 0x01	; 1
     c34:	f0 e0       	ldi	r31, 0x00	; 0
     c36:	ec 0f       	add	r30, r28
     c38:	fd 1f       	adc	r31, r29
     c3a:	e1 0f       	add	r30, r17
     c3c:	f1 1d       	adc	r31, r1
     c3e:	80 83       	st	Z, r24
     c40:	1f 5f       	subi	r17, 0xFF	; 255
     c42:	a1 f7       	brne	.-24     	; 0xc2c <memoryScan+0x46>
     c44:	2a 9a       	sbi	0x05, 2	; 5
     c46:	1f 2d       	mov	r17, r15
     c48:	01 c0       	rjmp	.+2      	; 0xc4c <memoryScan+0x66>
     c4a:	18 2f       	mov	r17, r24
     c4c:	e1 e0       	ldi	r30, 0x01	; 1
     c4e:	f0 e0       	ldi	r31, 0x00	; 0
     c50:	ec 0f       	add	r30, r28
     c52:	fd 1f       	adc	r31, r29
     c54:	e1 0f       	add	r30, r17
     c56:	f1 1d       	adc	r31, r1
     c58:	80 81       	ld	r24, Z
     c5a:	8f 3f       	cpi	r24, 0xFF	; 255
     c5c:	41 f0       	breq	.+16     	; 0xc6e <memoryScan+0x88>
     c5e:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
     c62:	81 2f       	mov	r24, r17
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	90 2b       	or	r25, r16
     c68:	8e 7f       	andi	r24, 0xFE	; 254
     c6a:	02 96       	adiw	r24, 0x02	; 2
     c6c:	0c c0       	rjmp	.+24     	; 0xc86 <memoryScan+0xa0>
     c6e:	8f ef       	ldi	r24, 0xFF	; 255
     c70:	81 0f       	add	r24, r17
     c72:	11 11       	cpse	r17, r1
     c74:	ea cf       	rjmp	.-44     	; 0xc4a <memoryScan+0x64>
     c76:	8f ef       	ldi	r24, 0xFF	; 255
     c78:	80 0f       	add	r24, r16
     c7a:	01 11       	cpse	r16, r1
     c7c:	c8 cf       	rjmp	.-112    	; 0xc0e <memoryScan+0x28>
     c7e:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	90 e0       	ldi	r25, 0x00	; 0
     c86:	c1 50       	subi	r28, 0x01	; 1
     c88:	df 4f       	sbci	r29, 0xFF	; 255
     c8a:	0f b6       	in	r0, 0x3f	; 63
     c8c:	f8 94       	cli
     c8e:	de bf       	out	0x3e, r29	; 62
     c90:	0f be       	out	0x3f, r0	; 63
     c92:	cd bf       	out	0x3d, r28	; 61
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	1f 91       	pop	r17
     c9a:	0f 91       	pop	r16
     c9c:	ff 90       	pop	r15
     c9e:	08 95       	ret

00000ca0 <memoryEraseChip>:
     ca0:	86 e0       	ldi	r24, 0x06	; 6
     ca2:	0e 94 04 05 	call	0xa08	; 0xa08 <_memorySingleCommand>
     ca6:	2a 98       	cbi	0x05, 2	; 5
     ca8:	80 e6       	ldi	r24, 0x60	; 96
     caa:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     cae:	2a 9a       	sbi	0x05, 2	; 5
     cb0:	08 95       	ret

00000cb2 <memoryReadStatusRegisters>:
     cb2:	2a 98       	cbi	0x05, 2	; 5
     cb4:	85 e0       	ldi	r24, 0x05	; 5
     cb6:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     cba:	80 e0       	ldi	r24, 0x00	; 0
     cbc:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     cc0:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <memory_status_byte_1>
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     cca:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <memory_status_byte_2>
     cce:	2a 9a       	sbi	0x05, 2	; 5
     cd0:	08 95       	ret

00000cd2 <memoryUltraDeepPowerDownEnter>:
     cd2:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
     cd6:	89 e7       	ldi	r24, 0x79	; 121
     cd8:	0e 94 04 05 	call	0xa08	; 0xa08 <_memorySingleCommand>
     cdc:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
     ce0:	08 95       	ret

00000ce2 <memoryUltraDeepPowerDownExitBegin>:
     ce2:	2a 98       	cbi	0x05, 2	; 5
     ce4:	82 e0       	ldi	r24, 0x02	; 2
     ce6:	8a 95       	dec	r24
     ce8:	f1 f7       	brne	.-4      	; 0xce6 <memoryUltraDeepPowerDownExitBegin+0x4>
     cea:	00 c0       	rjmp	.+0      	; 0xcec <memoryUltraDeepPowerDownExitBegin+0xa>
     cec:	2a 9a       	sbi	0x05, 2	; 5
     cee:	08 95       	ret

00000cf0 <memoryReadMFDID>:
     cf0:	2a 98       	cbi	0x05, 2	; 5
     cf2:	8f e9       	ldi	r24, 0x9F	; 159
     cf4:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     cfe:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <memory_manufacturer_id>
     d02:	80 e0       	ldi	r24, 0x00	; 0
     d04:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     d08:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <memory_device_id>
     d0c:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <memory_device_id+0x1>
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	0e 94 be 06 	call	0xd7c	; 0xd7c <spiTradeByte>
     d16:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <memory_device_id>
     d1a:	30 91 3f 01 	lds	r19, 0x013F	; 0x80013f <memory_device_id+0x1>
     d1e:	28 2b       	or	r18, r24
     d20:	30 93 3f 01 	sts	0x013F, r19	; 0x80013f <memory_device_id+0x1>
     d24:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <memory_device_id>
     d28:	2a 9a       	sbi	0x05, 2	; 5
     d2a:	08 95       	ret

00000d2c <memoryInitialize>:
     d2c:	22 9a       	sbi	0x04, 2	; 4
     d2e:	2a 9a       	sbi	0x05, 2	; 5
     d30:	10 92 c1 01 	sts	0x01C1, r1	; 0x8001c1 <memory_flags>
     d34:	0e 94 a3 06 	call	0xd46	; 0xd46 <spiEnable>
     d38:	0e 94 59 06 	call	0xcb2	; 0xcb2 <memoryReadStatusRegisters>
     d3c:	0e 94 78 06 	call	0xcf0	; 0xcf0 <memoryReadMFDID>
     d40:	0e 94 b1 06 	call	0xd62	; 0xd62 <spiDisable>
     d44:	08 95       	ret

00000d46 <spiEnable>:
     d46:	24 98       	cbi	0x04, 4	; 4
     d48:	2c 98       	cbi	0x05, 4	; 5
     d4a:	23 9a       	sbi	0x04, 3	; 4
     d4c:	2b 98       	cbi	0x05, 3	; 5
     d4e:	25 9a       	sbi	0x04, 5	; 4
     d50:	2d 98       	cbi	0x05, 5	; 5
     d52:	e4 e6       	ldi	r30, 0x64	; 100
     d54:	f0 e0       	ldi	r31, 0x00	; 0
     d56:	80 81       	ld	r24, Z
     d58:	8b 7f       	andi	r24, 0xFB	; 251
     d5a:	80 83       	st	Z, r24
     d5c:	80 e5       	ldi	r24, 0x50	; 80
     d5e:	8c bd       	out	0x2c, r24	; 44
     d60:	08 95       	ret

00000d62 <spiDisable>:
     d62:	1c bc       	out	0x2c, r1	; 44
     d64:	e4 e6       	ldi	r30, 0x64	; 100
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	80 81       	ld	r24, Z
     d6a:	84 60       	ori	r24, 0x04	; 4
     d6c:	80 83       	st	Z, r24
     d6e:	84 b1       	in	r24, 0x04	; 4
     d70:	87 7c       	andi	r24, 0xC7	; 199
     d72:	84 b9       	out	0x04, r24	; 4
     d74:	85 b1       	in	r24, 0x05	; 5
     d76:	88 63       	ori	r24, 0x38	; 56
     d78:	85 b9       	out	0x05, r24	; 5
     d7a:	08 95       	ret

00000d7c <spiTradeByte>:
     d7c:	8e bd       	out	0x2e, r24	; 46
     d7e:	0d b4       	in	r0, 0x2d	; 45
     d80:	07 fe       	sbrs	r0, 7
     d82:	fd cf       	rjmp	.-6      	; 0xd7e <spiTradeByte+0x2>
     d84:	8e b5       	in	r24, 0x2e	; 46
     d86:	08 95       	ret

00000d88 <systemLabelLoad>:
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	80 e0       	ldi	r24, 0x00	; 0
     d8e:	90 e0       	ldi	r25, 0x00	; 0
     d90:	0e 94 32 08 	call	0x1064	; 0x1064 <eeprom_read_byte>
     d94:	c8 2f       	mov	r28, r24
     d96:	d0 e0       	ldi	r29, 0x00	; 0
     d98:	dc 2f       	mov	r29, r28
     d9a:	cc 27       	eor	r28, r28
     d9c:	d0 93 c4 01 	sts	0x01C4, r29	; 0x8001c4 <system_label+0x1>
     da0:	c0 93 c3 01 	sts	0x01C3, r28	; 0x8001c3 <system_label>
     da4:	81 e0       	ldi	r24, 0x01	; 1
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	0e 94 32 08 	call	0x1064	; 0x1064 <eeprom_read_byte>
     dac:	c8 2b       	or	r28, r24
     dae:	d0 93 c4 01 	sts	0x01C4, r29	; 0x8001c4 <system_label+0x1>
     db2:	c0 93 c3 01 	sts	0x01C3, r28	; 0x8001c3 <system_label>
     db6:	df 91       	pop	r29
     db8:	cf 91       	pop	r28
     dba:	08 95       	ret

00000dbc <systemLabelGet>:
     dbc:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <system_label>
     dc0:	90 91 c4 01 	lds	r25, 0x01C4	; 0x8001c4 <system_label+0x1>
     dc4:	08 95       	ret

00000dc6 <systemLabelWrite>:
     dc6:	cf 93       	push	r28
     dc8:	c6 2f       	mov	r28, r22
     dca:	68 2f       	mov	r22, r24
     dcc:	80 e0       	ldi	r24, 0x00	; 0
     dce:	90 e0       	ldi	r25, 0x00	; 0
     dd0:	0e 94 3a 08 	call	0x1074	; 0x1074 <eeprom_update_byte>
     dd4:	6c 2f       	mov	r22, r28
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	90 e0       	ldi	r25, 0x00	; 0
     dda:	0e 94 3a 08 	call	0x1074	; 0x1074 <eeprom_update_byte>
     dde:	0e 94 c4 06 	call	0xd88	; 0xd88 <systemLabelLoad>
     de2:	cf 91       	pop	r28
     de4:	08 95       	ret

00000de6 <systemBootloaderGetAddress>:
     de6:	e3 e0       	ldi	r30, 0x03	; 3
     de8:	f0 e0       	ldi	r31, 0x00	; 0
     dea:	89 e0       	ldi	r24, 0x09	; 9
     dec:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
     df0:	84 91       	lpm	r24, Z
     df2:	86 70       	andi	r24, 0x06	; 6
     df4:	86 95       	lsr	r24
     df6:	80 95       	com	r24
     df8:	83 70       	andi	r24, 0x03	; 3
     dfa:	20 e0       	ldi	r18, 0x00	; 0
     dfc:	32 e0       	ldi	r19, 0x02	; 2
     dfe:	02 c0       	rjmp	.+4      	; 0xe04 <systemBootloaderGetAddress+0x1e>
     e00:	22 0f       	add	r18, r18
     e02:	33 1f       	adc	r19, r19
     e04:	8a 95       	dec	r24
     e06:	e2 f7       	brpl	.-8      	; 0xe00 <systemBootloaderGetAddress+0x1a>
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	90 e8       	ldi	r25, 0x80	; 128
     e0c:	82 1b       	sub	r24, r18
     e0e:	93 0b       	sbc	r25, r19
     e10:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <system_bootloader_address+0x1>
     e14:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <system_bootloader_address>
     e18:	08 95       	ret

00000e1a <_twiWaitForTWINT>:
     e1a:	ec eb       	ldi	r30, 0xBC	; 188
     e1c:	f0 e0       	ldi	r31, 0x00	; 0
     e1e:	80 81       	ld	r24, Z
     e20:	88 23       	and	r24, r24
     e22:	ec f7       	brge	.-6      	; 0xe1e <_twiWaitForTWINT+0x4>
     e24:	08 95       	ret

00000e26 <_twiTransmitNoAck>:
     e26:	84 e8       	ldi	r24, 0x84	; 132
     e28:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     e2c:	0e 94 0d 07 	call	0xe1a	; 0xe1a <_twiWaitForTWINT>
     e30:	08 95       	ret

00000e32 <_twiStatusIs>:
     e32:	20 91 b9 00 	lds	r18, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
     e36:	28 7f       	andi	r18, 0xF8	; 248
     e38:	30 e0       	ldi	r19, 0x00	; 0
     e3a:	48 2f       	mov	r20, r24
     e3c:	50 e0       	ldi	r21, 0x00	; 0
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	24 17       	cp	r18, r20
     e42:	35 07       	cpc	r19, r21
     e44:	09 f0       	breq	.+2      	; 0xe48 <_twiStatusIs+0x16>
     e46:	80 e0       	ldi	r24, 0x00	; 0
     e48:	08 95       	ret

00000e4a <_twiStartRegisterWrite>:
     e4a:	0f 93       	push	r16
     e4c:	1f 93       	push	r17
     e4e:	cf 93       	push	r28
     e50:	df 93       	push	r29
     e52:	08 2f       	mov	r16, r24
     e54:	16 2f       	mov	r17, r22
     e56:	84 ea       	ldi	r24, 0xA4	; 164
     e58:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     e5c:	0e 94 0d 07 	call	0xe1a	; 0xe1a <_twiWaitForTWINT>
     e60:	88 e0       	ldi	r24, 0x08	; 8
     e62:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     e66:	cb eb       	ldi	r28, 0xBB	; 187
     e68:	d0 e0       	ldi	r29, 0x00	; 0
     e6a:	08 83       	st	Y, r16
     e6c:	0e 94 13 07 	call	0xe26	; 0xe26 <_twiTransmitNoAck>
     e70:	88 e1       	ldi	r24, 0x18	; 24
     e72:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     e76:	18 83       	st	Y, r17
     e78:	0e 94 13 07 	call	0xe26	; 0xe26 <_twiTransmitNoAck>
     e7c:	88 e2       	ldi	r24, 0x28	; 40
     e7e:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	1f 91       	pop	r17
     e88:	0f 91       	pop	r16
     e8a:	08 95       	ret

00000e8c <_twiStartRegisterRead>:
     e8c:	cf 93       	push	r28
     e8e:	c8 2f       	mov	r28, r24
     e90:	0e 94 25 07 	call	0xe4a	; 0xe4a <_twiStartRegisterWrite>
     e94:	84 ea       	ldi	r24, 0xA4	; 164
     e96:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     e9a:	0e 94 0d 07 	call	0xe1a	; 0xe1a <_twiWaitForTWINT>
     e9e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
     ea2:	c1 60       	ori	r28, 0x01	; 1
     ea4:	c0 93 bb 00 	sts	0x00BB, r28	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     ea8:	0e 94 13 07 	call	0xe26	; 0xe26 <_twiTransmitNoAck>
     eac:	80 e4       	ldi	r24, 0x40	; 64
     eae:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     eb2:	cf 91       	pop	r28
     eb4:	08 95       	ret

00000eb6 <twiEnable>:
     eb6:	e4 e6       	ldi	r30, 0x64	; 100
     eb8:	f0 e0       	ldi	r31, 0x00	; 0
     eba:	80 81       	ld	r24, Z
     ebc:	8f 77       	andi	r24, 0x7F	; 127
     ebe:	80 83       	st	Z, r24
     ec0:	e9 eb       	ldi	r30, 0xB9	; 185
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	80 81       	ld	r24, Z
     ec6:	8c 7f       	andi	r24, 0xFC	; 252
     ec8:	80 83       	st	Z, r24
     eca:	80 81       	ld	r24, Z
     ecc:	80 83       	st	Z, r24
     ece:	80 e2       	ldi	r24, 0x20	; 32
     ed0:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
     ed4:	ec eb       	ldi	r30, 0xBC	; 188
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	80 81       	ld	r24, Z
     eda:	84 60       	ori	r24, 0x04	; 4
     edc:	80 83       	st	Z, r24
     ede:	08 95       	ret

00000ee0 <twiDisable>:
     ee0:	ec eb       	ldi	r30, 0xBC	; 188
     ee2:	f0 e0       	ldi	r31, 0x00	; 0
     ee4:	80 81       	ld	r24, Z
     ee6:	8b 7f       	andi	r24, 0xFB	; 251
     ee8:	80 83       	st	Z, r24
     eea:	e4 e6       	ldi	r30, 0x64	; 100
     eec:	f0 e0       	ldi	r31, 0x00	; 0
     eee:	80 81       	ld	r24, Z
     ef0:	80 68       	ori	r24, 0x80	; 128
     ef2:	80 83       	st	Z, r24
     ef4:	87 b1       	in	r24, 0x07	; 7
     ef6:	8f 7c       	andi	r24, 0xCF	; 207
     ef8:	87 b9       	out	0x07, r24	; 7
     efa:	88 b1       	in	r24, 0x08	; 8
     efc:	80 63       	ori	r24, 0x30	; 48
     efe:	88 b9       	out	0x08, r24	; 8
     f00:	08 95       	ret

00000f02 <twiDRead8>:
     f02:	cf 93       	push	r28
     f04:	0e 94 46 07 	call	0xe8c	; 0xe8c <_twiStartRegisterRead>
     f08:	0e 94 13 07 	call	0xe26	; 0xe26 <_twiTransmitNoAck>
     f0c:	c0 91 bb 00 	lds	r28, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     f10:	88 e5       	ldi	r24, 0x58	; 88
     f12:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     f16:	88 23       	and	r24, r24
     f18:	21 f0       	breq	.+8      	; 0xf22 <twiDRead8+0x20>
     f1a:	84 e9       	ldi	r24, 0x94	; 148
     f1c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     f20:	01 c0       	rjmp	.+2      	; 0xf24 <twiDRead8+0x22>
     f22:	ca ef       	ldi	r28, 0xFA	; 250
     f24:	8c 2f       	mov	r24, r28
     f26:	cf 91       	pop	r28
     f28:	08 95       	ret

00000f2a <twiDRead16>:
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
     f2e:	0e 94 46 07 	call	0xe8c	; 0xe8c <_twiStartRegisterRead>
     f32:	84 ec       	ldi	r24, 0xC4	; 196
     f34:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     f38:	0e 94 0d 07 	call	0xe1a	; 0xe1a <_twiWaitForTWINT>
     f3c:	d0 91 bb 00 	lds	r29, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     f40:	80 e5       	ldi	r24, 0x50	; 80
     f42:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     f46:	88 23       	and	r24, r24
     f48:	b1 f0       	breq	.+44     	; 0xf76 <twiDRead16+0x4c>
     f4a:	0e 94 13 07 	call	0xe26	; 0xe26 <_twiTransmitNoAck>
     f4e:	c0 91 bb 00 	lds	r28, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     f52:	88 e5       	ldi	r24, 0x58	; 88
     f54:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     f58:	88 23       	and	r24, r24
     f5a:	81 f0       	breq	.+32     	; 0xf7c <twiDRead16+0x52>
     f5c:	8d 2f       	mov	r24, r29
     f5e:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
     f62:	8c 2f       	mov	r24, r28
     f64:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
     f68:	84 e9       	ldi	r24, 0x94	; 148
     f6a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     f6e:	8c 2f       	mov	r24, r28
     f70:	90 e0       	ldi	r25, 0x00	; 0
     f72:	9d 2b       	or	r25, r29
     f74:	05 c0       	rjmp	.+10     	; 0xf80 <twiDRead16+0x56>
     f76:	8d ef       	ldi	r24, 0xFD	; 253
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	02 c0       	rjmp	.+4      	; 0xf80 <twiDRead16+0x56>
     f7c:	8e ef       	ldi	r24, 0xFE	; 254
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	df 91       	pop	r29
     f82:	cf 91       	pop	r28
     f84:	08 95       	ret

00000f86 <twiDWrite8>:
     f86:	cf 93       	push	r28
     f88:	c4 2f       	mov	r28, r20
     f8a:	0e 94 25 07 	call	0xe4a	; 0xe4a <_twiStartRegisterWrite>
     f8e:	c0 93 bb 00 	sts	0x00BB, r28	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     f92:	0e 94 13 07 	call	0xe26	; 0xe26 <_twiTransmitNoAck>
     f96:	88 e2       	ldi	r24, 0x28	; 40
     f98:	0e 94 19 07 	call	0xe32	; 0xe32 <_twiStatusIs>
     f9c:	84 e9       	ldi	r24, 0x94	; 148
     f9e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     fa2:	cf 91       	pop	r28
     fa4:	08 95       	ret

00000fa6 <uartEnable>:
     fa6:	e4 e6       	ldi	r30, 0x64	; 100
     fa8:	f0 e0       	ldi	r31, 0x00	; 0
     faa:	80 81       	ld	r24, Z
     fac:	8d 7f       	andi	r24, 0xFD	; 253
     fae:	80 83       	st	Z, r24
     fb0:	88 e1       	ldi	r24, 0x18	; 24
     fb2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     fb6:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     fba:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     fbe:	e0 ec       	ldi	r30, 0xC0	; 192
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
     fc2:	80 81       	ld	r24, Z
     fc4:	82 60       	ori	r24, 0x02	; 2
     fc6:	80 83       	st	Z, r24
     fc8:	80 81       	ld	r24, Z
     fca:	8f 7d       	andi	r24, 0xDF	; 223
     fcc:	80 83       	st	Z, r24
     fce:	8e e0       	ldi	r24, 0x0E	; 14
     fd0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     fd4:	08 95       	ret

00000fd6 <uartDisable>:
     fd6:	82 e4       	ldi	r24, 0x42	; 66
     fd8:	8a 95       	dec	r24
     fda:	f1 f7       	brne	.-4      	; 0xfd8 <uartDisable+0x2>
     fdc:	00 c0       	rjmp	.+0      	; 0xfde <uartDisable+0x8>
     fde:	e1 ec       	ldi	r30, 0xC1	; 193
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	80 81       	ld	r24, Z
     fe4:	87 76       	andi	r24, 0x67	; 103
     fe6:	80 83       	st	Z, r24
     fe8:	e4 e6       	ldi	r30, 0x64	; 100
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	80 81       	ld	r24, Z
     fee:	82 60       	ori	r24, 0x02	; 2
     ff0:	80 83       	st	Z, r24
     ff2:	8a b1       	in	r24, 0x0a	; 10
     ff4:	8c 7f       	andi	r24, 0xFC	; 252
     ff6:	8a b9       	out	0x0a, r24	; 10
     ff8:	8b b1       	in	r24, 0x0b	; 11
     ffa:	83 60       	ori	r24, 0x03	; 3
     ffc:	8b b9       	out	0x0b, r24	; 11
     ffe:	08 95       	ret

00001000 <uartRxInterruptEnable>:
    1000:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1004:	84 ff       	sbrs	r24, 4
    1006:	05 c0       	rjmp	.+10     	; 0x1012 <uartRxInterruptEnable+0x12>
    1008:	e1 ec       	ldi	r30, 0xC1	; 193
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	80 81       	ld	r24, Z
    100e:	80 68       	ori	r24, 0x80	; 128
    1010:	80 83       	st	Z, r24
    1012:	08 95       	ret

00001014 <uartSendByte>:
    1014:	e0 ec       	ldi	r30, 0xC0	; 192
    1016:	f0 e0       	ldi	r31, 0x00	; 0
    1018:	90 81       	ld	r25, Z
    101a:	95 ff       	sbrs	r25, 5
    101c:	fd cf       	rjmp	.-6      	; 0x1018 <uartSendByte+0x4>
    101e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1022:	08 95       	ret

00001024 <uartSendWord>:
    1024:	cf 93       	push	r28
    1026:	c8 2f       	mov	r28, r24
    1028:	89 2f       	mov	r24, r25
    102a:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
    102e:	8c 2f       	mov	r24, r28
    1030:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
    1034:	cf 91       	pop	r28
    1036:	08 95       	ret

00001038 <uartSendString>:
    1038:	0f 93       	push	r16
    103a:	1f 93       	push	r17
    103c:	cf 93       	push	r28
    103e:	fc 01       	movw	r30, r24
    1040:	80 81       	ld	r24, Z
    1042:	88 23       	and	r24, r24
    1044:	59 f0       	breq	.+22     	; 0x105c <uartSendString+0x24>
    1046:	8f 01       	movw	r16, r30
    1048:	c0 e0       	ldi	r28, 0x00	; 0
    104a:	0e 94 0a 08 	call	0x1014	; 0x1014 <uartSendByte>
    104e:	cf 5f       	subi	r28, 0xFF	; 255
    1050:	f8 01       	movw	r30, r16
    1052:	ec 0f       	add	r30, r28
    1054:	f1 1d       	adc	r31, r1
    1056:	80 81       	ld	r24, Z
    1058:	81 11       	cpse	r24, r1
    105a:	f7 cf       	rjmp	.-18     	; 0x104a <uartSendString+0x12>
    105c:	cf 91       	pop	r28
    105e:	1f 91       	pop	r17
    1060:	0f 91       	pop	r16
    1062:	08 95       	ret

00001064 <eeprom_read_byte>:
    1064:	f9 99       	sbic	0x1f, 1	; 31
    1066:	fe cf       	rjmp	.-4      	; 0x1064 <eeprom_read_byte>
    1068:	92 bd       	out	0x22, r25	; 34
    106a:	81 bd       	out	0x21, r24	; 33
    106c:	f8 9a       	sbi	0x1f, 0	; 31
    106e:	99 27       	eor	r25, r25
    1070:	80 b5       	in	r24, 0x20	; 32
    1072:	08 95       	ret

00001074 <eeprom_update_byte>:
    1074:	26 2f       	mov	r18, r22

00001076 <eeprom_update_r18>:
    1076:	f9 99       	sbic	0x1f, 1	; 31
    1078:	fe cf       	rjmp	.-4      	; 0x1076 <eeprom_update_r18>
    107a:	92 bd       	out	0x22, r25	; 34
    107c:	81 bd       	out	0x21, r24	; 33
    107e:	f8 9a       	sbi	0x1f, 0	; 31
    1080:	01 97       	sbiw	r24, 0x01	; 1
    1082:	00 b4       	in	r0, 0x20	; 32
    1084:	02 16       	cp	r0, r18
    1086:	39 f0       	breq	.+14     	; 0x1096 <eeprom_update_r18+0x20>
    1088:	1f ba       	out	0x1f, r1	; 31
    108a:	20 bd       	out	0x20, r18	; 32
    108c:	0f b6       	in	r0, 0x3f	; 63
    108e:	f8 94       	cli
    1090:	fa 9a       	sbi	0x1f, 2	; 31
    1092:	f9 9a       	sbi	0x1f, 1	; 31
    1094:	0f be       	out	0x3f, r0	; 63
    1096:	08 95       	ret

00001098 <_exit>:
    1098:	f8 94       	cli

0000109a <__stop_program>:
    109a:	ff cf       	rjmp	.-2      	; 0x109a <__stop_program>
