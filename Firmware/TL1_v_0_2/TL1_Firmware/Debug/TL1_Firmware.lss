
TL1_Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00001096  0000112a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001096  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000c1  00800106  00800106  00001130  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001130  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001160  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000490  00000000  00000000  000011a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003ee9  00000000  00000000  00001630  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017b9  00000000  00000000  00005519  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000249f  00000000  00000000  00006cd2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a88  00000000  00000000  00009174  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010d6  00000000  00000000  00009bfc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002257  00000000  00000000  0000acd2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000470  00000000  00000000  0000cf29  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 e7 00 	jmp	0x1ce	; 0x1ce <__vector_9>
      28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__vector_18>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d8 e0       	ldi	r29, 0x08	; 8
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e6 e9       	ldi	r30, 0x96	; 150
      c8:	f0 e1       	ldi	r31, 0x10	; 16
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	a6 30       	cpi	r26, 0x06	; 6
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	21 e0       	ldi	r18, 0x01	; 1
      d8:	a6 e0       	ldi	r26, 0x06	; 6
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a7 3c       	cpi	r26, 0xC7	; 199
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 6e 03 	call	0x6dc	; 0x6dc <main>
      ea:	0c 94 49 08 	jmp	0x1092	; 0x1092 <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <adcEnable>:

/*
 *  Initialize the ADC
 */
void adcEnable(void) {
    PRR0 &= ~(1<<PRADC);                  // Disable ADC power reduction mode. Not sure this is needed.
      f2:	e4 e6       	ldi	r30, 0x64	; 100
      f4:	f0 e0       	ldi	r31, 0x00	; 0
      f6:	80 81       	ld	r24, Z
      f8:	8e 7f       	andi	r24, 0xFE	; 254
      fa:	80 83       	st	Z, r24
    ADMUX &= ~(1<<REFS1);					// Set AVcc as ...
      fc:	ec e7       	ldi	r30, 0x7C	; 124
      fe:	f0 e0       	ldi	r31, 0x00	; 0
     100:	80 81       	ld	r24, Z
     102:	8f 77       	andi	r24, 0x7F	; 127
     104:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0);                   // ... reference voltage
     106:	80 81       	ld	r24, Z
     108:	80 64       	ori	r24, 0x40	; 64
     10a:	80 83       	st	Z, r24
    ADCSRA |= (1<<ADPS2)|(1<<ADPS1);        // ADC clock prescaler / 64 = 9260SPS. Datasheet p.250
     10c:	aa e7       	ldi	r26, 0x7A	; 122
     10e:	b0 e0       	ldi	r27, 0x00	; 0
     110:	8c 91       	ld	r24, X
     112:	86 60       	ori	r24, 0x06	; 6
     114:	8c 93       	st	X, r24
    ADCSRA |= (1 << ADEN);                  // Enable ADC
     116:	8c 91       	ld	r24, X
     118:	80 68       	ori	r24, 0x80	; 128
     11a:	8c 93       	st	X, r24
	ADMUX &= ~(0b1111);         // Reset channel bits
     11c:	80 81       	ld	r24, Z
     11e:	80 7f       	andi	r24, 0xF0	; 240
     120:	80 83       	st	Z, r24
    ADMUX |= 0b1110;			// Set channel to measure internal 1.1V bandgap.
     122:	80 81       	ld	r24, Z
     124:	8e 60       	ori	r24, 0x0E	; 14
     126:	80 83       	st	Z, r24
     128:	08 95       	ret

0000012a <adcDisable>:
}

void adcDisable(void) {
	ADCSRA &= ~(1<<ADEN);		// Disable ADC
     12a:	ea e7       	ldi	r30, 0x7A	; 122
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	80 81       	ld	r24, Z
     130:	8f 77       	andi	r24, 0x7F	; 127
     132:	80 83       	st	Z, r24
	PRR0 |= 1<<PRADC;			// Set ADC in power reduction register.
     134:	e4 e6       	ldi	r30, 0x64	; 100
     136:	f0 e0       	ldi	r31, 0x00	; 0
     138:	80 81       	ld	r24, Z
     13a:	81 60       	ori	r24, 0x01	; 1
     13c:	80 83       	st	Z, r24
     13e:	08 95       	ret

00000140 <adcReadVoltage>:
}

uint16_t adcReadVoltage(void) {
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
	adcEnable();
     144:	0e 94 79 00 	call	0xf2	; 0xf2 <adcEnable>
     148:	94 e1       	ldi	r25, 0x14	; 20
    uint16_t return_value = 0;
	for (uint8_t i=0; i<20; i++) {
		ADCSRA |= (1<<ADSC);                                // Start a single-ended conversion
     14a:	ea e7       	ldi	r30, 0x7A	; 122
     14c:	f0 e0       	ldi	r31, 0x00	; 0
		loop_until_bit_is_clear(ADCSRA, ADSC);
		return_value = ADC;
     14e:	a8 e7       	ldi	r26, 0x78	; 120
     150:	b0 e0       	ldi	r27, 0x00	; 0

uint16_t adcReadVoltage(void) {
	adcEnable();
    uint16_t return_value = 0;
	for (uint8_t i=0; i<20; i++) {
		ADCSRA |= (1<<ADSC);                                // Start a single-ended conversion
     152:	80 81       	ld	r24, Z
     154:	80 64       	ori	r24, 0x40	; 64
     156:	80 83       	st	Z, r24
		loop_until_bit_is_clear(ADCSRA, ADSC);
     158:	80 81       	ld	r24, Z
     15a:	86 fd       	sbrc	r24, 6
     15c:	fd cf       	rjmp	.-6      	; 0x158 <adcReadVoltage+0x18>
		return_value = ADC;
     15e:	cd 91       	ld	r28, X+
     160:	dc 91       	ld	r29, X
     162:	11 97       	sbiw	r26, 0x01	; 1
     164:	91 50       	subi	r25, 0x01	; 1
}

uint16_t adcReadVoltage(void) {
	adcEnable();
    uint16_t return_value = 0;
	for (uint8_t i=0; i<20; i++) {
     166:	a9 f7       	brne	.-22     	; 0x152 <adcReadVoltage+0x12>
		ADCSRA |= (1<<ADSC);                                // Start a single-ended conversion
		loop_until_bit_is_clear(ADCSRA, ADSC);
		return_value = ADC;
	}
	adcDisable();
     168:	0e 94 95 00 	call	0x12a	; 0x12a <adcDisable>
	return return_value;
}
     16c:	ce 01       	movw	r24, r28
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <errorInitFlags>:
void errorSetFlag(uint16_t flag_to_set) {
	error_flags |= (1<<flag_to_set);
}

void errorClearFlag(uint16_t flag_to_clear) {
	error_flags &= ~(1<<flag_to_clear);
     174:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <__data_end+0x1>
     178:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <__data_end>
     17c:	08 95       	ret

0000017e <errorSetFlag>:
     17e:	21 e0       	ldi	r18, 0x01	; 1
     180:	30 e0       	ldi	r19, 0x00	; 0
     182:	02 c0       	rjmp	.+4      	; 0x188 <errorSetFlag+0xa>
     184:	22 0f       	add	r18, r18
     186:	33 1f       	adc	r19, r19
     188:	8a 95       	dec	r24
     18a:	e2 f7       	brpl	.-8      	; 0x184 <errorSetFlag+0x6>
     18c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
     190:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <__data_end+0x1>
     194:	28 2b       	or	r18, r24
     196:	39 2b       	or	r19, r25
     198:	30 93 07 01 	sts	0x0107, r19	; 0x800107 <__data_end+0x1>
     19c:	20 93 06 01 	sts	0x0106, r18	; 0x800106 <__data_end>
     1a0:	08 95       	ret

000001a2 <errorClearAll>:
#include "error.h"

uint16_t error_flags;					// Flags to indicate status of device. POR defaults to 0x00.

void errorInitFlags(void) {
	error_flags = 0;
     1a2:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <__data_end+0x1>
     1a6:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <__data_end>
     1aa:	08 95       	ret

000001ac <errorGetFlags>:
	errorInitFlags();
}

uint16_t errorGetFlags(void) {
	return error_flags;
     1ac:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
     1b0:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <__data_end+0x1>
     1b4:	08 95       	ret

000001b6 <indicatorInitialize>:

/*
 * Turn indicator off.
 */
void indicatorOff(void) {
	INDICATOR_OFF;
     1b6:	69 9a       	sbi	0x0d, 1	; 13
     1b8:	71 98       	cbi	0x0e, 1	; 14
     1ba:	08 95       	ret

000001bc <indicatorShortBlink>:
}
/*
 * Emit the shortest, barely visible, light pulse. Indicates normal operation.
 */
void indicatorShortBlink(void) {
	INDICATOR_ON;
     1bc:	71 9a       	sbi	0x0e, 1	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1be:	8f ec       	ldi	r24, 0xCF	; 207
     1c0:	97 e0       	ldi	r25, 0x07	; 7
     1c2:	01 97       	sbiw	r24, 0x01	; 1
     1c4:	f1 f7       	brne	.-4      	; 0x1c2 <indicatorShortBlink+0x6>
     1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <indicatorShortBlink+0xc>
     1c8:	00 00       	nop
	_delay_ms(1);
	INDICATOR_OFF;}
     1ca:	71 98       	cbi	0x0e, 1	; 14
     1cc:	08 95       	ret

000001ce <__vector_9>:


/*
 * Timer 2 is the Real Time Counter, set to fire every 8 seconds.
 */
ISR(TIMER2_OVF_vect) {
     1ce:	1f 92       	push	r1
     1d0:	0f 92       	push	r0
     1d2:	0f b6       	in	r0, 0x3f	; 63
     1d4:	0f 92       	push	r0
     1d6:	11 24       	eor	r1, r1
     1d8:	8f 93       	push	r24
     1da:	9f 93       	push	r25
	logger_eightseconds_count++;
     1dc:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <logger_eightseconds_count>
     1e0:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <logger_eightseconds_count+0x1>
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <logger_eightseconds_count+0x1>
     1ea:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <logger_eightseconds_count>
}
     1ee:	9f 91       	pop	r25
     1f0:	8f 91       	pop	r24
     1f2:	0f 90       	pop	r0
     1f4:	0f be       	out	0x3f, r0	; 63
     1f6:	0f 90       	pop	r0
     1f8:	1f 90       	pop	r1
     1fa:	18 95       	reti

000001fc <__vector_18>:



ISR(USART0_RX_vect) {
     1fc:	1f 92       	push	r1
     1fe:	0f 92       	push	r0
     200:	0f b6       	in	r0, 0x3f	; 63
     202:	0f 92       	push	r0
     204:	11 24       	eor	r1, r1
     206:	2f 93       	push	r18
     208:	3f 93       	push	r19
     20a:	4f 93       	push	r20
     20c:	5f 93       	push	r21
     20e:	6f 93       	push	r22
     210:	7f 93       	push	r23
     212:	8f 93       	push	r24
     214:	9f 93       	push	r25
     216:	af 93       	push	r26
     218:	bf 93       	push	r27
     21a:	ef 93       	push	r30
     21c:	ff 93       	push	r31
	if (rx_buffer_index<RX_BUFFER_LENGTH) {
     21e:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <rx_buffer_index>
     222:	84 31       	cpi	r24, 0x14	; 20
     224:	70 f4       	brcc	.+28     	; 0x242 <__vector_18+0x46>
		rx_buffer_array[rx_buffer_index] = UDR0;
     226:	e0 91 28 01 	lds	r30, 0x0128	; 0x800128 <rx_buffer_index>
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     230:	e4 5f       	subi	r30, 0xF4	; 244
     232:	fe 4f       	sbci	r31, 0xFE	; 254
     234:	80 83       	st	Z, r24
		rx_buffer_index++;	
     236:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <rx_buffer_index>
     23a:	8f 5f       	subi	r24, 0xFF	; 255
     23c:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <rx_buffer_index>
     240:	04 c0       	rjmp	.+8      	; 0x24a <__vector_18+0x4e>
	} else {
		errorSetFlag(ERROR_FLAG_RX_BUFFER_OVF);
     242:	83 e0       	ldi	r24, 0x03	; 3
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 bf 00 	call	0x17e	; 0x17e <errorSetFlag>
	}
}
     24a:	ff 91       	pop	r31
     24c:	ef 91       	pop	r30
     24e:	bf 91       	pop	r27
     250:	af 91       	pop	r26
     252:	9f 91       	pop	r25
     254:	8f 91       	pop	r24
     256:	7f 91       	pop	r23
     258:	6f 91       	pop	r22
     25a:	5f 91       	pop	r21
     25c:	4f 91       	pop	r20
     25e:	3f 91       	pop	r19
     260:	2f 91       	pop	r18
     262:	0f 90       	pop	r0
     264:	0f be       	out	0x3f, r0	; 63
     266:	0f 90       	pop	r0
     268:	1f 90       	pop	r1
     26a:	18 95       	reti

0000026c <rxBufferClear>:


/*
 * Clear the rx buffer and its index.
 */
void rxBufferClear(void) {
     26c:	80 e0       	ldi	r24, 0x00	; 0
     26e:	90 e0       	ldi	r25, 0x00	; 0
	for(uint8_t i=0; i<RX_BUFFER_LENGTH; i++) {
		rx_buffer_array[i] = 0;
     270:	fc 01       	movw	r30, r24
     272:	e4 5f       	subi	r30, 0xF4	; 244
     274:	fe 4f       	sbci	r31, 0xFE	; 254
     276:	10 82       	st	Z, r1
     278:	01 96       	adiw	r24, 0x01	; 1

/*
 * Clear the rx buffer and its index.
 */
void rxBufferClear(void) {
	for(uint8_t i=0; i<RX_BUFFER_LENGTH; i++) {
     27a:	84 31       	cpi	r24, 0x14	; 20
     27c:	91 05       	cpc	r25, r1
     27e:	c1 f7       	brne	.-16     	; 0x270 <rxBufferClear+0x4>
		rx_buffer_array[i] = 0;
	}
	rx_buffer_index = 0;
     280:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <rx_buffer_index>
     284:	08 95       	ret

00000286 <rxBufferIsAllZeros>:
}

uint8_t rxBufferIsAllZeros(void) {
	for (uint8_t i=1; i<20; i++) {
		if (rx_buffer_array[i]!=0) return 0;
     286:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rx_buffer_array+0x1>
     28a:	81 11       	cpse	r24, r1
     28c:	0f c0       	rjmp	.+30     	; 0x2ac <rxBufferIsAllZeros+0x26>
     28e:	22 e0       	ldi	r18, 0x02	; 2
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	f9 01       	movw	r30, r18
     294:	e4 5f       	subi	r30, 0xF4	; 244
     296:	fe 4f       	sbci	r31, 0xFE	; 254
     298:	90 81       	ld	r25, Z
     29a:	91 11       	cpse	r25, r1
     29c:	08 c0       	rjmp	.+16     	; 0x2ae <rxBufferIsAllZeros+0x28>
     29e:	2f 5f       	subi	r18, 0xFF	; 255
     2a0:	3f 4f       	sbci	r19, 0xFF	; 255
	}
	rx_buffer_index = 0;
}

uint8_t rxBufferIsAllZeros(void) {
	for (uint8_t i=1; i<20; i++) {
     2a2:	24 31       	cpi	r18, 0x14	; 20
     2a4:	31 05       	cpc	r19, r1
     2a6:	a9 f7       	brne	.-22     	; 0x292 <rxBufferIsAllZeros+0xc>
		if (rx_buffer_array[i]!=0) return 0;
	}
	return 1;
     2a8:	81 e0       	ldi	r24, 0x01	; 1
     2aa:	08 95       	ret
	rx_buffer_index = 0;
}

uint8_t rxBufferIsAllZeros(void) {
	for (uint8_t i=1; i<20; i++) {
		if (rx_buffer_array[i]!=0) return 0;
     2ac:	80 e0       	ldi	r24, 0x00	; 0
	}
	return 1;
}
     2ae:	08 95       	ret

000002b0 <rxBufferCommandIsReady>:

uint8_t rxBufferCommandIsReady(void) {
	if (rx_buffer_index==20) {
     2b0:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <rx_buffer_index>
     2b4:	84 31       	cpi	r24, 0x14	; 20
     2b6:	59 f4       	brne	.+22     	; 0x2ce <rxBufferCommandIsReady+0x1e>
		if ((rx_buffer_array[0]>'A') && (rx_buffer_array[0]<'Z')) {	// Commands are only cap letters
     2b8:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     2bc:	82 34       	cpi	r24, 0x42	; 66
     2be:	48 f0       	brcs	.+18     	; 0x2d2 <rxBufferCommandIsReady+0x22>
     2c0:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <rx_buffer_array>
			return 1;
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	9a 35       	cpi	r25, 0x5A	; 90
     2c8:	28 f0       	brcs	.+10     	; 0x2d4 <rxBufferCommandIsReady+0x24>
     2ca:	80 e0       	ldi	r24, 0x00	; 0
     2cc:	08 95       	ret
		}
	}
	return 0;
     2ce:	80 e0       	ldi	r24, 0x00	; 0
     2d0:	08 95       	ret
     2d2:	80 e0       	ldi	r24, 0x00	; 0
}
     2d4:	08 95       	ret

000002d6 <rxBufferTimestampIsValid>:
 */
uint8_t rxBufferTimestampIsValid(void) {
	// Check that rx_buffer_array bytes 1-18 are all ASCII numerals ('0' to '9')
	// This check can be improved in future.
	for (uint8_t i=1; i<15; i++) { // Check timestamp section of command string
		if ((rx_buffer_array[i] < '0') || (rx_buffer_array[i] > '9')) {
     2d6:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rx_buffer_array+0x1>
     2da:	80 33       	cpi	r24, 0x30	; 48
     2dc:	08 f1       	brcs	.+66     	; 0x320 <rxBufferTimestampIsValid+0x4a>
     2de:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <rx_buffer_array+0x1>
     2e2:	8a 33       	cpi	r24, 0x3A	; 58
     2e4:	f8 f4       	brcc	.+62     	; 0x324 <rxBufferTimestampIsValid+0x4e>
     2e6:	82 e0       	ldi	r24, 0x02	; 2
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	fc 01       	movw	r30, r24
     2ec:	e4 5f       	subi	r30, 0xF4	; 244
     2ee:	fe 4f       	sbci	r31, 0xFE	; 254
     2f0:	20 81       	ld	r18, Z
     2f2:	20 33       	cpi	r18, 0x30	; 48
     2f4:	c8 f0       	brcs	.+50     	; 0x328 <rxBufferTimestampIsValid+0x52>
     2f6:	fc 01       	movw	r30, r24
     2f8:	e4 5f       	subi	r30, 0xF4	; 244
     2fa:	fe 4f       	sbci	r31, 0xFE	; 254
     2fc:	20 81       	ld	r18, Z
     2fe:	2a 33       	cpi	r18, 0x3A	; 58
     300:	a8 f4       	brcc	.+42     	; 0x32c <rxBufferTimestampIsValid+0x56>
     302:	01 96       	adiw	r24, 0x01	; 1
 * always at the same location in the array.
 */
uint8_t rxBufferTimestampIsValid(void) {
	// Check that rx_buffer_array bytes 1-18 are all ASCII numerals ('0' to '9')
	// This check can be improved in future.
	for (uint8_t i=1; i<15; i++) { // Check timestamp section of command string
     304:	8f 30       	cpi	r24, 0x0F	; 15
     306:	91 05       	cpc	r25, r1
     308:	81 f7       	brne	.-32     	; 0x2ea <rxBufferTimestampIsValid+0x14>
		if ((rx_buffer_array[i] < '0') || (rx_buffer_array[i] > '9')) {
			return 0;
		}
	}
	if ((rx_buffer_array[15]!='A') && (rx_buffer_array[15]!='L')) {
     30a:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <rx_buffer_array+0xf>
     30e:	81 34       	cpi	r24, 0x41	; 65
     310:	79 f0       	breq	.+30     	; 0x330 <rxBufferTimestampIsValid+0x5a>
     312:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <rx_buffer_array+0xf>
uint8_t rxBufferTimestampIsValid(void) {
	// Check that rx_buffer_array bytes 1-18 are all ASCII numerals ('0' to '9')
	// This check can be improved in future.
	for (uint8_t i=1; i<15; i++) { // Check timestamp section of command string
		if ((rx_buffer_array[i] < '0') || (rx_buffer_array[i] > '9')) {
			return 0;
     316:	81 e0       	ldi	r24, 0x01	; 1
     318:	9c 34       	cpi	r25, 0x4C	; 76
     31a:	59 f0       	breq	.+22     	; 0x332 <rxBufferTimestampIsValid+0x5c>
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	08 95       	ret
     320:	80 e0       	ldi	r24, 0x00	; 0
     322:	08 95       	ret
     324:	80 e0       	ldi	r24, 0x00	; 0
     326:	08 95       	ret
     328:	80 e0       	ldi	r24, 0x00	; 0
     32a:	08 95       	ret
     32c:	80 e0       	ldi	r24, 0x00	; 0
     32e:	08 95       	ret
		}
	}
	if ((rx_buffer_array[15]!='A') && (rx_buffer_array[15]!='L')) {
		return 0;
	}
	return 1;
     330:	81 e0       	ldi	r24, 0x01	; 1
}
     332:	08 95       	ret

00000334 <hostCommandReceive>:

/*
 * Send host a string of info and receive a command.
 */
void hostCommandReceive(void) {
     334:	0f 93       	push	r16
     336:	1f 93       	push	r17
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
	// Send logger info string (4 bytes of model, 3 bytes of MCU ID (why?), 10 bytes of MCU serial number (OK), 2 bytes of firmware CRC, 6 status-dependent bytes.
	logger_battery_level = adcReadVoltage();
     33c:	0e 94 a0 00 	call	0x140	; 0x140 <adcReadVoltage>
     340:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <logger_battery_level+0x1>
     344:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <logger_battery_level>
	rxBufferClear();									// Clear rx_buffer_array and rx_buffer_index.
     348:	0e 94 36 01 	call	0x26c	; 0x26c <rxBufferClear>
	uartEnable();										// Enable uart module.
     34c:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <uartEnable>
	uartRxInterruptEnable();							// Enable RX receive interrupt.
     350:	0e 94 fd 07 	call	0xffa	; 0xffa <uartRxInterruptEnable>

	uartSendString("TL01");							// 4 bytes of system model.
     354:	80 e0       	ldi	r24, 0x00	; 0
     356:	91 e0       	ldi	r25, 0x01	; 1
     358:	0e 94 19 08 	call	0x1032	; 0x1032 <uartSendString>
     35c:	cd e2       	ldi	r28, 0x2D	; 45
     35e:	d1 e0       	ldi	r29, 0x01	; 1
     360:	07 e3       	ldi	r16, 0x37	; 55
     362:	11 e0       	ldi	r17, 0x01	; 1
	for (uint8_t i=0; i<10; i++) {
		uartSendByte(mcu_serial_number[i]);				// 10 bytes of mcu serial number
     364:	89 91       	ld	r24, Y+
     366:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
	rxBufferClear();									// Clear rx_buffer_array and rx_buffer_index.
	uartEnable();										// Enable uart module.
	uartRxInterruptEnable();							// Enable RX receive interrupt.

	uartSendString("TL01");							// 4 bytes of system model.
	for (uint8_t i=0; i<10; i++) {
     36a:	c0 17       	cp	r28, r16
     36c:	d1 07       	cpc	r29, r17
     36e:	d1 f7       	brne	.-12     	; 0x364 <hostCommandReceive+0x30>
		uartSendByte(mcu_serial_number[i]);				// 10 bytes of mcu serial number
	}
	uartSendWord(systemLabelGet());					// 2 bytes of local serial.
     370:	0e 94 db 06 	call	0xdb6	; 0xdb6 <systemLabelGet>
     374:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
	uartSendByte(FIRMWARE_GET_VERSION);					// 1 byte of firmware version
     378:	82 e0       	ldi	r24, 0x02	; 2
     37a:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
	uartSendWord(mcu_firmware_crc16_xmodem);			// 2 bytes of firmware CRC16-xmodem
     37e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <mcu_firmware_crc16_xmodem>
     382:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <mcu_firmware_crc16_xmodem+0x1>
     386:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
	uartSendWord(logger_battery_level);					// 2 bytes of battery level or 0 if not available
     38a:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <logger_battery_level>
     38e:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <logger_battery_level+0x1>
     392:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
	uartSendWord(errorGetFlags());						// 2 bytes of error flags (0x0000 for no errors)
     396:	0e 94 d6 00 	call	0x1ac	; 0x1ac <errorGetFlags>
     39a:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
	uartSendWord(0x0000);								// 2 bytes reserved for future use
     39e:	80 e0       	ldi	r24, 0x00	; 0
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
	// Hereon depends on status. Work on this.
	uartSendByte(logger_mode);						// Status: [I]dle, [L]ogging, [H]olding, [D]ownloaded.
     3a6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     3aa:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
	if (logger_mode=='L') {
     3ae:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     3b2:	8c 34       	cpi	r24, 0x4C	; 76
     3b4:	c9 f4       	brne	.+50     	; 0x3e8 <hostCommandReceive+0xb4>
		uartSendWord(logger_memory_location);			// 2 bytes of data length (bytes, including header)
     3b6:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     3ba:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     3be:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(logger_countdown);					// 2 bytes of logger countdown (deferral)
     3c2:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <logger_countdown>
     3c6:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <logger_countdown+0x1>
     3ca:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(logger_eightseconds_count);		// 2 bytes of current eightseconds count.
     3ce:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <logger_eightseconds_count>
     3d2:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <logger_eightseconds_count+0x1>
     3d6:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(logger_interval);					// 2 bytes of logger interval.		
     3da:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <logger_interval>
     3de:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <logger_interval+0x1>
     3e2:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
     3e6:	38 c0       	rjmp	.+112    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	} else if (logger_mode=='H') {
     3e8:	88 34       	cpi	r24, 0x48	; 72
     3ea:	99 f4       	brne	.+38     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
		uartSendWord(logger_memory_location);			// 2 bytes of data length (bytes, including header)
     3ec:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     3f0:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     3f4:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes of data CRC
     3f8:	80 e0       	ldi	r24, 0x00	; 0
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     400:	80 e0       	ldi	r24, 0x00	; 0
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     408:	80 e0       	ldi	r24, 0x00	; 0
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
     410:	23 c0       	rjmp	.+70     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	} else if (logger_mode=='I') {
     412:	89 34       	cpi	r24, 0x49	; 73
     414:	89 f4       	brne	.+34     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     416:	80 e0       	ldi	r24, 0x00	; 0
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     41e:	80 e0       	ldi	r24, 0x00	; 0
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
     436:	10 c0       	rjmp	.+32     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	} else {
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     438:	80 e0       	ldi	r24, 0x00	; 0
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     440:	80 e0       	ldi	r24, 0x00	; 0
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     448:	80 e0       	ldi	r24, 0x00	; 0
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
		uartSendWord(0x0000);							// 2 bytes reserved for future use
     450:	80 e0       	ldi	r24, 0x00	; 0
     452:	90 e0       	ldi	r25, 0x00	; 0
     454:	0e 94 0f 08 	call	0x101e	; 0x101e <uartSendWord>
     458:	2f ef       	ldi	r18, 0xFF	; 255
     45a:	80 e7       	ldi	r24, 0x70	; 112
     45c:	92 e0       	ldi	r25, 0x02	; 2
     45e:	21 50       	subi	r18, 0x01	; 1
     460:	80 40       	sbci	r24, 0x00	; 0
     462:	90 40       	sbci	r25, 0x00	; 0
     464:	e1 f7       	brne	.-8      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     466:	00 c0       	rjmp	.+0      	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
     468:	00 00       	nop
	}

	_delay_ms(RX_RECEIVE_TIMEOUT);		// Wait for command string to arrive at rx_buffer_array via RX ISR.
										// Delay instead of polling or counting bytes prevents lock-down.
	uartDisable();						// End of command string receival. Shut the uart module down.
     46a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <uartDisable>
	
	if (rxBufferCommandIsReady()) {
     46e:	0e 94 58 01 	call	0x2b0	; 0x2b0 <rxBufferCommandIsReady>
     472:	88 23       	and	r24, r24
     474:	09 f4       	brne	.+2      	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
     476:	29 c1       	rjmp	.+594    	; 0x6ca <__LOCK_REGION_LENGTH__+0x2ca>
		// Commands applicable to all modes
		if (rx_buffer_array[0] == 'N') {
     478:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     47c:	8e 34       	cpi	r24, 0x4E	; 78
     47e:	09 f4       	brne	.+2      	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
     480:	28 c1       	rjmp	.+592    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			; // Do nothing
		} else if (rx_buffer_array[0] == 'X') {
     482:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     486:	88 35       	cpi	r24, 0x58	; 88
     488:	41 f4       	brne	.+16     	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
			if (rxBufferIsAllZeros()) {
     48a:	0e 94 43 01 	call	0x286	; 0x286 <rxBufferIsAllZeros>
     48e:	88 23       	and	r24, r24
     490:	09 f4       	brne	.+2      	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
     492:	1f c1       	rjmp	.+574    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				errorClearAll();
     494:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <errorClearAll>
     498:	1c c1       	rjmp	.+568    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'E') {
     49a:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     49e:	85 34       	cpi	r24, 0x45	; 69
     4a0:	09 f0       	breq	.+2      	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
     4a2:	78 c0       	rjmp	.+240    	; 0x594 <__LOCK_REGION_LENGTH__+0x194>
			if (logger_mode=='L' && rxBufferTimestampIsValid()) {
     4a4:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     4a8:	8c 34       	cpi	r24, 0x4C	; 76
     4aa:	09 f0       	breq	.+2      	; 0x4ae <__LOCK_REGION_LENGTH__+0xae>
     4ac:	12 c1       	rjmp	.+548    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
     4ae:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <rxBufferTimestampIsValid>
     4b2:	88 23       	and	r24, r24
     4b4:	09 f4       	brne	.+2      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
     4b6:	0d c1       	rjmp	.+538    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				/*
				 * TODO: Why doesn't this code put memory back to ultra-deep power down?
				 */
				spiEnable();
     4b8:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
				// Write Data CRC to memory (2 bytes)
				memoryWriteByte(logger_memory_location, 'C');
     4bc:	63 e4       	ldi	r22, 0x43	; 67
     4be:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4c2:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     4c6:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     4ca:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4ce:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     4d2:	01 96       	adiw	r24, 0x01	; 1
     4d4:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     4d8:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'C');
     4dc:	63 e4       	ldi	r22, 0x43	; 67
     4de:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     4e2:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4e6:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     4ea:	01 96       	adiw	r24, 0x01	; 1
     4ec:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     4f0:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				// Write number of records to memory (2 bytes)
				memoryWriteByte(logger_memory_location, 'N');
     4f4:	6e e4       	ldi	r22, 0x4E	; 78
     4f6:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     4fa:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     4fe:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     502:	01 96       	adiw	r24, 0x01	; 1
     504:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     508:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'N');
     50c:	6e e4       	ldi	r22, 0x4E	; 78
     50e:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     512:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     516:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     51a:	01 96       	adiw	r24, 0x01	; 1
     51c:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     520:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				// Append rx_buffer_array bytes 
				memoryWriteArray(logger_memory_location, (uint8_t *) &rx_buffer_array[1], 15);
     524:	4f e0       	ldi	r20, 0x0F	; 15
     526:	6d e0       	ldi	r22, 0x0D	; 13
     528:	71 e0       	ldi	r23, 0x01	; 1
     52a:	0e 94 85 05 	call	0xb0a	; 0xb0a <memoryWriteArray>
				logger_memory_location += 15;
     52e:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     532:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     536:	0f 96       	adiw	r24, 0x0f	; 15
     538:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     53c:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 0x00);
     540:	60 e0       	ldi	r22, 0x00	; 0
     542:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     546:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     54a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     54e:	01 96       	adiw	r24, 0x01	; 1
     550:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     554:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'C');
     558:	63 e4       	ldi	r22, 0x43	; 67
     55a:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     55e:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     562:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     566:	01 96       	adiw	r24, 0x01	; 1
     568:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     56c:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				memoryWriteByte(logger_memory_location, 'C');
     570:	63 e4       	ldi	r22, 0x43	; 67
     572:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
				logger_memory_location++;
     576:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     57a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     57e:	01 96       	adiw	r24, 0x01	; 1
     580:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     584:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
				spiDisable();
     588:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
				// Also set status/mode to 'H'
				logger_mode = 'H';
     58c:	88 e4       	ldi	r24, 0x48	; 72
     58e:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     592:	9f c0       	rjmp	.+318    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'D') {
     594:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     598:	84 34       	cpi	r24, 0x44	; 68
     59a:	f1 f4       	brne	.+60     	; 0x5d8 <__LOCK_REGION_LENGTH__+0x1d8>
			if (rxBufferIsAllZeros()) {
     59c:	0e 94 43 01 	call	0x286	; 0x286 <rxBufferIsAllZeros>
     5a0:	88 23       	and	r24, r24
     5a2:	09 f4       	brne	.+2      	; 0x5a6 <__LOCK_REGION_LENGTH__+0x1a6>
     5a4:	96 c0       	rjmp	.+300    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				if (logger_mode=='I' /*DEBUG*/ || logger_mode=='L' || logger_mode=='H' || logger_mode=='D')	// Modify
     5a6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     5aa:	98 eb       	ldi	r25, 0xB8	; 184
     5ac:	98 0f       	add	r25, r24
     5ae:	92 30       	cpi	r25, 0x02	; 2
     5b0:	20 f0       	brcs	.+8      	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
     5b2:	87 7f       	andi	r24, 0xF7	; 247
     5b4:	84 34       	cpi	r24, 0x44	; 68
     5b6:	09 f0       	breq	.+2      	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
     5b8:	8c c0       	rjmp	.+280    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
					memoryDumpUpto(logger_memory_location);	// Stream out memory bytes, byte per byte, from 0 to logger_memory_location.
     5ba:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     5be:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     5c2:	0e 94 bb 05 	call	0xb76	; 0xb76 <memoryDumpUpto>
				if (logger_mode=='H')
     5c6:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     5ca:	88 34       	cpi	r24, 0x48	; 72
     5cc:	09 f0       	breq	.+2      	; 0x5d0 <__LOCK_REGION_LENGTH__+0x1d0>
     5ce:	81 c0       	rjmp	.+258    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
					logger_mode='D';
     5d0:	84 e4       	ldi	r24, 0x44	; 68
     5d2:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     5d6:	7d c0       	rjmp	.+250    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'C') { // Something in here gets stuck
     5d8:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     5dc:	83 34       	cpi	r24, 0x43	; 67
     5de:	c1 f4       	brne	.+48     	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
			if (logger_mode=='D' && rxBufferIsAllZeros()) {
     5e0:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     5e4:	84 34       	cpi	r24, 0x44	; 68
     5e6:	09 f0       	breq	.+2      	; 0x5ea <__LOCK_REGION_LENGTH__+0x1ea>
     5e8:	74 c0       	rjmp	.+232    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
     5ea:	0e 94 43 01 	call	0x286	; 0x286 <rxBufferIsAllZeros>
     5ee:	88 23       	and	r24, r24
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <__LOCK_REGION_LENGTH__+0x1f4>
     5f2:	6f c0       	rjmp	.+222    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				/*
				 * TODO: Why doesn't this code put memory back to ultra-deep power down?
				 */
				spiEnable();
     5f4:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
				memoryEraseChip();	//Clear memory
     5f8:	0e 94 4d 06 	call	0xc9a	; 0xc9a <memoryEraseChip>
				spiDisable();
     5fc:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
				logger_mode = 'I';
     600:	89 e4       	ldi	r24, 0x49	; 73
     602:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
				logger_memory_location = 0;		// Rewind to 0
     606:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <logger_memory_location+0x1>
     60a:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <logger_memory_location>
     60e:	61 c0       	rjmp	.+194    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		} else if (rx_buffer_array[0] == 'U') {
     610:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     614:	85 35       	cpi	r24, 0x55	; 85
     616:	09 f4       	brne	.+2      	; 0x61a <__LOCK_REGION_LENGTH__+0x21a>
     618:	5c c0       	rjmp	.+184    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			;// Do a firmware update. Here, just reset device.
		} else if (rx_buffer_array[0] == 'B') {
     61a:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     61e:	82 34       	cpi	r24, 0x42	; 66
     620:	09 f0       	breq	.+2      	; 0x624 <__LOCK_REGION_LENGTH__+0x224>
     622:	44 c0       	rjmp	.+136    	; 0x6ac <__LOCK_REGION_LENGTH__+0x2ac>
			if (logger_mode=='I' && rxBufferTimestampIsValid()) {
     624:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     628:	89 34       	cpi	r24, 0x49	; 73
     62a:	09 f0       	breq	.+2      	; 0x62e <__LOCK_REGION_LENGTH__+0x22e>
     62c:	52 c0       	rjmp	.+164    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
     62e:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <rxBufferTimestampIsValid>
     632:	88 23       	and	r24, r24
     634:	09 f4       	brne	.+2      	; 0x638 <__LOCK_REGION_LENGTH__+0x238>
     636:	4d c0       	rjmp	.+154    	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
					logger_countdown = rx_buffer_array[16];
     638:	ec e0       	ldi	r30, 0x0C	; 12
     63a:	f1 e0       	ldi	r31, 0x01	; 1
     63c:	20 89       	ldd	r18, Z+16	; 0x10
					logger_countdown <<= 8;
					logger_countdown |= rx_buffer_array[17];
     63e:	81 89       	ldd	r24, Z+17	; 0x11
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	92 2b       	or	r25, r18
     644:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <logger_countdown+0x1>
     648:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <logger_countdown>
					logger_interval = rx_buffer_array[18];
     64c:	22 89       	ldd	r18, Z+18	; 0x12
					logger_interval <<= 8;
					logger_interval |= rx_buffer_array[19];
     64e:	83 89       	ldd	r24, Z+19	; 0x13
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	92 2b       	or	r25, r18
     654:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <logger_interval+0x1>
     658:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <logger_interval>
					// Copy format version (0x01), and rx_buffer_array 1-18 to first 22 bytes in EEPROM.
					/*
					 * TODO: Why doesn't this code put memory back to ultra-deep power down?
					 */
					spiEnable();
     65c:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
					memoryWriteByte(0x0000, 0x01);						// Format version
     660:	61 e0       	ldi	r22, 0x01	; 1
     662:	80 e0       	ldi	r24, 0x00	; 0
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
					memoryWriteArray(0x0001, (uint8_t *) &rx_buffer_array[1], 19);	// Copy timestamp, source, countdown, and interval to memory array.
     66a:	43 e1       	ldi	r20, 0x13	; 19
     66c:	6d e0       	ldi	r22, 0x0D	; 13
     66e:	71 e0       	ldi	r23, 0x01	; 1
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	0e 94 85 05 	call	0xb0a	; 0xb0a <memoryWriteArray>
					memoryWriteByte(0x0014, 'C');	// Memory address 20 (to be CRC MSB)
     678:	63 e4       	ldi	r22, 0x43	; 67
     67a:	84 e1       	ldi	r24, 0x14	; 20
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
					memoryWriteByte(0x0015, 'C');	// Memory address 21 (to be CRC LSB)
     682:	63 e4       	ldi	r22, 0x43	; 67
     684:	85 e1       	ldi	r24, 0x15	; 21
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	0e 94 4d 05 	call	0xa9a	; 0xa9a <memoryWriteByte>
					spiDisable();
     68c:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
					logger_memory_location = 22;				// For next (first) temperature log
     690:	86 e1       	ldi	r24, 0x16	; 22
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     698:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
					logger_mode = 'L';							// Set logger_status to 'L'
     69c:	8c e4       	ldi	r24, 0x4C	; 76
     69e:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
					logger_eightseconds_count = 0;				// Reset eightseconds counter.
     6a2:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <logger_eightseconds_count+0x1>
     6a6:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <logger_eightseconds_count>
     6aa:	13 c0       	rjmp	.+38     	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			} 
		} else if (rx_buffer_array[0] == 'S') {		// Set logger label number.
     6ac:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rx_buffer_array>
     6b0:	83 35       	cpi	r24, 0x53	; 83
     6b2:	79 f4       	brne	.+30     	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			if (rx_buffer_array[2]) {	// 2nd byte must have a value. 1st can have a value or be 0.
     6b4:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <rx_buffer_array+0x2>
     6b8:	88 23       	and	r24, r24
     6ba:	59 f0       	breq	.+22     	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
				systemLabelWrite(rx_buffer_array[1], rx_buffer_array[2]);
     6bc:	ec e0       	ldi	r30, 0x0C	; 12
     6be:	f1 e0       	ldi	r31, 0x01	; 1
     6c0:	62 81       	ldd	r22, Z+2	; 0x02
     6c2:	81 81       	ldd	r24, Z+1	; 0x01
     6c4:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <systemLabelWrite>
     6c8:	04 c0       	rjmp	.+8      	; 0x6d2 <__LOCK_REGION_LENGTH__+0x2d2>
			}
		}
	} else {  // Logger didn't receive complete command
        errorSetFlag(ERROR_FLAG_COMMAND_ERR);
     6ca:	84 e0       	ldi	r24, 0x04	; 4
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	0e 94 bf 00 	call	0x17e	; 0x17e <errorSetFlag>
    }
}
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	1f 91       	pop	r17
     6d8:	0f 91       	pop	r16
     6da:	08 95       	ret

000006dc <main>:
/*
 * MAIN function, consists of initialization code and an eternal while(1) loop.
 */
int main(void) {
	// Initialize the system. So many things!
	MCUSR = 0;
     6dc:	14 be       	out	0x34, r1	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	a8 95       	wdr
     6e4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     6e8:	88 61       	ori	r24, 0x18	; 24
     6ea:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     6ee:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
     6f2:	0f be       	out	0x3f, r0	; 63
	wdt_disable();			// Disable watchdog timer, in case this was preserved after soft-reset.
	// Disable brown-out detector in sleep mode.
	MCUCR |= (1<<BODSE)|(1<<BODS);
     6f4:	85 b7       	in	r24, 0x35	; 53
     6f6:	80 66       	ori	r24, 0x60	; 96
     6f8:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1<<BODS);
     6fa:	85 b7       	in	r24, 0x35	; 53
     6fc:	80 64       	ori	r24, 0x40	; 64
     6fe:	85 bf       	out	0x35, r24	; 53
	MCUCR &= ~(1<<BODSE);
     700:	85 b7       	in	r24, 0x35	; 53
     702:	8f 7d       	andi	r24, 0xDF	; 223
     704:	85 bf       	out	0x35, r24	; 53

	// Disable ADC
	ADCSRA &= ~(1<<ADEN);					// Disable ADC, stops the ADC clock.
     706:	ea e7       	ldi	r30, 0x7A	; 122
     708:	f0 e0       	ldi	r31, 0x00	; 0
     70a:	80 81       	ld	r24, Z
     70c:	8f 77       	andi	r24, 0x7F	; 127
     70e:	80 83       	st	Z, r24

	// TODO: Disable watchdog timer (Fuse FUSE_WDTON, defaults to ...) Also WDTCSR
	// TODO: Disconnect the bandgap reference from the Analog Comparator (clear the ACBG bit in	ACSR (ACSR.ACBG)).
	ACSR |= (1<<ACD);						// Disable analog comparator (set to disable).
     710:	80 b7       	in	r24, 0x30	; 48
     712:	80 68       	ori	r24, 0x80	; 128
     714:	80 bf       	out	0x30, r24	; 48

	PRR0 |= (1<<PRTWI0)|(1<<PRTIM2)|(1<<PRTIM0)|(1<<PRUSART1)|(1<<PRTIM1)|(1<<PRSPI0)|(1<<PRUSART0)|(1<<PRADC);
     716:	c4 e6       	ldi	r28, 0x64	; 100
     718:	d0 e0       	ldi	r29, 0x00	; 0
     71a:	88 81       	ld	r24, Y
     71c:	8f ef       	ldi	r24, 0xFF	; 255
     71e:	88 83       	st	Y, r24
	PRR1 |= (1<<PRTWI1)|(1<<PRPTC)|(1<<PRTIM4)|(1<<PRSPI1)|(1<<PRTIM3);
     720:	e5 e6       	ldi	r30, 0x65	; 101
     722:	f0 e0       	ldi	r31, 0x00	; 0
     724:	90 81       	ld	r25, Z
     726:	9d 63       	ori	r25, 0x3D	; 61
     728:	90 83       	st	Z, r25
	//SMCR &= ~((1<<SM2)|(1<<SM0));
	//SMCR |= (1<<SM1);

	// Set all ports to input and high before initializing modules that may override these as necessary.
	// Turn all unused pins into inputs with pull-ups.
	DDRB  = 0x00;
     72a:	14 b8       	out	0x04, r1	; 4
	PORTB = 0xFF;
     72c:	85 b9       	out	0x05, r24	; 5
	DDRC  &= ~((1<<DDRC0)|(1<<DDRC1)|(1<<DDRC2)|(1<<DDRC3)|(1<<DDRC4)|(1<<DDRC5)|(1<<DDRC6));		// Port C is 7 bits (0-6).
     72e:	97 b1       	in	r25, 0x07	; 7
     730:	90 78       	andi	r25, 0x80	; 128
     732:	97 b9       	out	0x07, r25	; 7
	PORTC |= ((1<<PORTC0)|(1<<PORTC1)|(1<<PORTC2)|(1<<PORTC3)|(1<<PORTC4)|(1<<PORTC5)|(1<<PORTC6));
     734:	98 b1       	in	r25, 0x08	; 8
     736:	9f 67       	ori	r25, 0x7F	; 127
     738:	98 b9       	out	0x08, r25	; 8
	DDRD  = 0x00;
     73a:	1a b8       	out	0x0a, r1	; 10
	PORTD = 0xFF;
     73c:	8b b9       	out	0x0b, r24	; 11
	DDRE  &= ~((1<<DDRE0)|(1<<DDRE1)|(1<<DDRE3));
     73e:	8d b1       	in	r24, 0x0d	; 13
     740:	84 7f       	andi	r24, 0xF4	; 244
     742:	8d b9       	out	0x0d, r24	; 13
	PORTE |= ((1<<PORTE0)|(1<<PORTE1)|(1<<PORTE3));
     744:	8e b1       	in	r24, 0x0e	; 14
     746:	8b 60       	ori	r24, 0x0B	; 11
     748:	8e b9       	out	0x0e, r24	; 14
	DDRE |= (1<<DDRE2);
     74a:	6a 9a       	sbi	0x0d, 2	; 13
	PORTE &= ~(1<<PORTE2);					// Stays here
     74c:	72 98       	cbi	0x0e, 2	; 14
	
	
	//Digital input buffers can be disabled by writing to the Digital Input Disable Registers (DIDR0 for ADC, DIDR1 for AC). (found at http://microchipdeveloper.com/8avr:avrsleep)
	//If the On-chip debug system is enabled by the DWEN Fuse and the chip enters sleep mode, the main clock source is enabled and hence always consumes power. In the deeper sleep modes, this will contribute significantly to the total current consumption.

	errorInitFlags();
     74e:	0e 94 ba 00 	call	0x174	; 0x174 <errorInitFlags>
	indicatorInitialize();
     752:	0e 94 db 00 	call	0x1b6	; 0x1b6 <indicatorInitialize>
		
	// Start the Real Time Counter. Takes 1000ms+ to allow crystal to stabilize.
	PRR0	&= ~(1<<PRTIM2);								// Clear timer2 bit at power reduction register.
     756:	88 81       	ld	r24, Y
     758:	8f 7b       	andi	r24, 0xBF	; 191
     75a:	88 83       	st	Y, r24
	ASSR	|= (1<<AS2);									// Clock from external crystal.
     75c:	e6 eb       	ldi	r30, 0xB6	; 182
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	80 81       	ld	r24, Z
     762:	80 62       	ori	r24, 0x20	; 32
     764:	80 83       	st	Z, r24
	TCCR2B	|= (1<<CS20)|(1<<CS21)|(1<<CS22);				// Tosc/1024 prescaler = 8sec to overflow.
     766:	e1 eb       	ldi	r30, 0xB1	; 177
     768:	f0 e0       	ldi	r31, 0x00	; 0
     76a:	80 81       	ld	r24, Z
     76c:	87 60       	ori	r24, 0x07	; 7
     76e:	80 83       	st	Z, r24
	TIMSK2	= 0;
     770:	e0 e7       	ldi	r30, 0x70	; 112
     772:	f0 e0       	ldi	r31, 0x00	; 0
     774:	10 82       	st	Z, r1
	TIMSK2	|= (1<<TOIE2);									// Enable overflow interrupt
     776:	80 81       	ld	r24, Z
     778:	81 60       	ori	r24, 0x01	; 1
     77a:	80 83       	st	Z, r24
	//_delay_ms(1000);										// Allow RTC crystal to stabilize (RTC AN p.5).
	TCNT2	= 0;											// Clear counter value.
     77c:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
	sei();	
     780:	78 94       	sei
	
	max30205Init();									// Initialize temperature sensor chip into lowest power consumption.
     782:	0e 94 d6 04 	call	0x9ac	; 0x9ac <max30205Init>
	
	// Initialize memory chip and set it to low power.
	memoryInitialize();								// Initialize memory chip.
     786:	0e 94 93 06 	call	0xd26	; 0xd26 <memoryInitialize>
	logger_memory_location = memoryScan();			// Find byte address of first blank word. Should be 0.
     78a:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <memoryScan>
     78e:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     792:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
	memoryUltraDeepPowerDownEnter();				// Place memory chip into lowest power consumption.
     796:	0e 94 66 06 	call	0xccc	; 0xccc <memoryUltraDeepPowerDownEnter>
	
	// Check memory if empty. If not, set logger in 'Holding' mode.
	if (logger_memory_location) {
     79a:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     79e:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     7a2:	89 2b       	or	r24, r25
     7a4:	21 f0       	breq	.+8      	; 0x7ae <main+0xd2>
		logger_mode = 'H';
     7a6:	88 e4       	ldi	r24, 0x48	; 72
     7a8:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     7ac:	d7 c0       	rjmp	.+430    	; 0x95c <__stack+0x5d>
	} else {
		logger_mode = 'I';
     7ae:	89 e4       	ldi	r24, 0x49	; 73
     7b0:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <logger_mode>
     7b4:	d3 c0       	rjmp	.+422    	; 0x95c <__stack+0x5d>
	}


	// Load MCU serial number.
	for (uint8_t i=0; i<10; i++) {
		mcu_serial_number[i] = boot_signature_byte_get(i+14);	// Read signature bytes 14-23
     7b6:	fc 01       	movw	r30, r24
     7b8:	ea 0f       	add	r30, r26
     7ba:	fb 1f       	adc	r31, r27
     7bc:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
     7c0:	e4 91       	lpm	r30, Z
     7c2:	ed 93       	st	X+, r30
		logger_mode = 'I';
	}


	// Load MCU serial number.
	for (uint8_t i=0; i<10; i++) {
     7c4:	4a 17       	cp	r20, r26
     7c6:	5b 07       	cpc	r21, r27
     7c8:	b1 f7       	brne	.-20     	; 0x7b6 <main+0xda>
		mcu_serial_number[i] = boot_signature_byte_get(i+14);	// Read signature bytes 14-23
	}
	systemLabelLoad();
     7ca:	0e 94 c1 06 	call	0xd82	; 0xd82 <systemLabelLoad>
	
	mcu_bootloader_first_byte = systemBootloaderGetAddress();
     7ce:	0e 94 f0 06 	call	0xde0	; 0xde0 <systemBootloaderGetAddress>
     7d2:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <mcu_bootloader_first_byte+0x1>
     7d6:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <mcu_bootloader_first_byte>
	mcu_firmware_available_pages = mcu_bootloader_first_byte / SPM_PAGESIZE;
     7da:	9c 01       	movw	r18, r24
     7dc:	22 0f       	add	r18, r18
     7de:	23 2f       	mov	r18, r19
     7e0:	22 1f       	adc	r18, r18
     7e2:	33 0b       	sbc	r19, r19
     7e4:	31 95       	neg	r19
     7e6:	30 93 2a 01 	sts	0x012A, r19	; 0x80012a <mcu_firmware_available_pages+0x1>
     7ea:	20 93 29 01 	sts	0x0129, r18	; 0x800129 <mcu_firmware_available_pages>

	// Find the last byte of firmware in flash.
	for (uint16_t k=(mcu_bootloader_first_byte-1); k>0; k--) {
     7ee:	fc 01       	movw	r30, r24
     7f0:	31 97       	sbiw	r30, 0x01	; 1
     7f2:	71 f0       	breq	.+28     	; 0x810 <main+0x134>
		if (pgm_read_byte(k) != 0xFF) {
     7f4:	84 91       	lpm	r24, Z
     7f6:	8f 3f       	cpi	r24, 0xFF	; 255
     7f8:	49 f0       	breq	.+18     	; 0x80c <main+0x130>
     7fa:	03 c0       	rjmp	.+6      	; 0x802 <main+0x126>
     7fc:	84 91       	lpm	r24, Z
     7fe:	8f 3f       	cpi	r24, 0xFF	; 255
     800:	29 f0       	breq	.+10     	; 0x80c <main+0x130>
			mcu_firmware_last_byte = k;
     802:	f0 93 23 01 	sts	0x0123, r31	; 0x800123 <mcu_firmware_last_byte+0x1>
     806:	e0 93 22 01 	sts	0x0122, r30	; 0x800122 <mcu_firmware_last_byte>
			break;
     80a:	02 c0       	rjmp	.+4      	; 0x810 <main+0x134>
	
	mcu_bootloader_first_byte = systemBootloaderGetAddress();
	mcu_firmware_available_pages = mcu_bootloader_first_byte / SPM_PAGESIZE;

	// Find the last byte of firmware in flash.
	for (uint16_t k=(mcu_bootloader_first_byte-1); k>0; k--) {
     80c:	31 97       	sbiw	r30, 0x01	; 1
     80e:	b1 f7       	brne	.-20     	; 0x7fc <main+0x120>
		}
	}

	// Calculate firmware xmodem CRC16
	mcu_firmware_crc16_xmodem = 0;
	for (uint16_t i=0; i<=mcu_firmware_last_byte; i++) {
     810:	40 91 22 01 	lds	r20, 0x0122	; 0x800122 <mcu_firmware_last_byte>
     814:	50 91 23 01 	lds	r21, 0x0123	; 0x800123 <mcu_firmware_last_byte+0x1>
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	e0 e0       	ldi	r30, 0x00	; 0
     81e:	f0 e0       	ldi	r31, 0x00	; 0
		mcu_firmware_crc16_xmodem = _crc_xmodem_update(mcu_firmware_crc16_xmodem, pgm_read_byte(i));
     820:	24 91       	lpm	r18, Z
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
     822:	92 27       	eor	r25, r18
     824:	09 2e       	mov	r0, r25
     826:	02 94       	swap	r0
     828:	20 2d       	mov	r18, r0
     82a:	2f 70       	andi	r18, 0x0F	; 15
     82c:	29 27       	eor	r18, r25
     82e:	39 2f       	mov	r19, r25
     830:	30 25       	eor	r19, r0
     832:	33 0f       	add	r19, r19
     834:	30 7e       	andi	r19, 0xE0	; 224
     836:	23 27       	eor	r18, r19
     838:	30 2d       	mov	r19, r0
     83a:	39 27       	eor	r19, r25
     83c:	30 7f       	andi	r19, 0xF0	; 240
     83e:	36 95       	lsr	r19
     840:	09 2e       	mov	r0, r25
     842:	00 0c       	add	r0, r0
     844:	33 1f       	adc	r19, r19
     846:	96 95       	lsr	r25
     848:	96 95       	lsr	r25
     84a:	96 95       	lsr	r25
     84c:	9f 71       	andi	r25, 0x1F	; 31
     84e:	93 27       	eor	r25, r19
     850:	98 27       	eor	r25, r24
     852:	82 2f       	mov	r24, r18
		}
	}

	// Calculate firmware xmodem CRC16
	mcu_firmware_crc16_xmodem = 0;
	for (uint16_t i=0; i<=mcu_firmware_last_byte; i++) {
     854:	31 96       	adiw	r30, 0x01	; 1
     856:	4e 17       	cp	r20, r30
     858:	5f 07       	cpc	r21, r31
     85a:	10 f7       	brcc	.-60     	; 0x820 <main+0x144>
     85c:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <mcu_firmware_crc16_xmodem>
     860:	90 93 3b 01 	sts	0x013B, r25	; 0x80013b <mcu_firmware_crc16_xmodem+0x1>
		mcu_firmware_crc16_xmodem = _crc_xmodem_update(mcu_firmware_crc16_xmodem, pgm_read_byte(i));
	}

	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
     864:	83 b7       	in	r24, 0x33	; 51
     866:	81 7f       	andi	r24, 0xF1	; 241
     868:	86 60       	ori	r24, 0x06	; 6
     86a:	83 bf       	out	0x33, r24	; 51
			} else if (logger_eightseconds_count<logger_interval) {
					// Do nothing. logger_eightseconds_count is incremented at ISR
			} else {
				if (logger_memory_location < LOGGER_HEADER_SIZE) {	// Wrapped through end of memory? (No way!)
					errorSetFlag(ERROR_FLAG_MEM_ADDRESS_ERR);
					logger_mode = 'H';
     86c:	c8 e4       	ldi	r28, 0x48	; 72
	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
	/*******************************************
	*               MAIN LOOP                  *
	*******************************************/
    while (1) {
		sleep_mode();
     86e:	83 b7       	in	r24, 0x33	; 51
     870:	81 60       	ori	r24, 0x01	; 1
     872:	83 bf       	out	0x33, r24	; 51
     874:	88 95       	sleep
     876:	83 b7       	in	r24, 0x33	; 51
     878:	8e 7f       	andi	r24, 0xFE	; 254
     87a:	83 bf       	out	0x33, r24	; 51
		if (logger_mode == 'L') {
     87c:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <logger_mode>
     880:	8c 34       	cpi	r24, 0x4C	; 76
     882:	09 f0       	breq	.+2      	; 0x886 <main+0x1aa>
     884:	65 c0       	rjmp	.+202    	; 0x950 <__stack+0x51>
			if (logger_countdown>0) {
     886:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <logger_countdown>
     88a:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <logger_countdown+0x1>
     88e:	00 97       	sbiw	r24, 0x00	; 0
     890:	51 f0       	breq	.+20     	; 0x8a6 <main+0x1ca>
				logger_countdown--;
     892:	01 97       	sbiw	r24, 0x01	; 1
     894:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <logger_countdown+0x1>
     898:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <logger_countdown>
				logger_eightseconds_count = 0;
     89c:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <logger_eightseconds_count+0x1>
     8a0:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <logger_eightseconds_count>
     8a4:	55 c0       	rjmp	.+170    	; 0x950 <__stack+0x51>
			} else if (logger_eightseconds_count<logger_interval) {
     8a6:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <logger_eightseconds_count>
     8aa:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <logger_eightseconds_count+0x1>
     8ae:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <logger_interval>
     8b2:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <logger_interval+0x1>
     8b6:	28 17       	cp	r18, r24
     8b8:	39 07       	cpc	r19, r25
     8ba:	08 f4       	brcc	.+2      	; 0x8be <main+0x1e2>
     8bc:	49 c0       	rjmp	.+146    	; 0x950 <__stack+0x51>
					// Do nothing. logger_eightseconds_count is incremented at ISR
			} else {
				if (logger_memory_location < LOGGER_HEADER_SIZE) {	// Wrapped through end of memory? (No way!)
     8be:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     8c2:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     8c6:	46 97       	sbiw	r24, 0x16	; 22
     8c8:	38 f4       	brcc	.+14     	; 0x8d8 <main+0x1fc>
					errorSetFlag(ERROR_FLAG_MEM_ADDRESS_ERR);
     8ca:	85 e0       	ldi	r24, 0x05	; 5
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	0e 94 bf 00 	call	0x17e	; 0x17e <errorSetFlag>
					logger_mode = 'H';
     8d2:	c0 93 37 01 	sts	0x0137, r28	; 0x800137 <logger_mode>
     8d6:	3c c0       	rjmp	.+120    	; 0x950 <__stack+0x51>
				} else {
					memoryUltraDeepPowerDownExitBegin();
     8d8:	0e 94 6e 06 	call	0xcdc	; 0xcdc <memoryUltraDeepPowerDownExitBegin>
					max30205StartOneShot();
     8dc:	0e 94 df 04 	call	0x9be	; 0x9be <max30205StartOneShot>
     8e0:	2f ef       	ldi	r18, 0xFF	; 255
     8e2:	86 e7       	ldi	r24, 0x76	; 118
     8e4:	91 e0       	ldi	r25, 0x01	; 1
     8e6:	21 50       	subi	r18, 0x01	; 1
     8e8:	80 40       	sbci	r24, 0x00	; 0
     8ea:	90 40       	sbci	r25, 0x00	; 0
     8ec:	e1 f7       	brne	.-8      	; 0x8e6 <main+0x20a>
     8ee:	00 c0       	rjmp	.+0      	; 0x8f0 <main+0x214>
     8f0:	00 00       	nop
					_delay_ms(60);										// Wait for MAX30205 to read temperature.
					logger_temperature = max30205ReadTemperature();
     8f2:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <max30205ReadTemperature>
     8f6:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <logger_temperature+0x1>
     8fa:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <logger_temperature>
     8fe:	8f e3       	ldi	r24, 0x3F	; 63
     900:	9c e9       	ldi	r25, 0x9C	; 156
     902:	01 97       	sbiw	r24, 0x01	; 1
     904:	f1 f7       	brne	.-4      	; 0x902 <__stack+0x3>
     906:	00 c0       	rjmp	.+0      	; 0x908 <__stack+0x9>
     908:	00 00       	nop
					_delay_ms(20);										// Wait for memory to recover from deep power down.
					spiEnable();
     90a:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
					memoryWriteWord(logger_memory_location, logger_temperature);
     90e:	60 91 2b 01 	lds	r22, 0x012B	; 0x80012b <logger_temperature>
     912:	70 91 2c 01 	lds	r23, 0x012C	; 0x80012c <logger_temperature+0x1>
     916:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     91a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     91e:	0e 94 66 05 	call	0xacc	; 0xacc <memoryWriteWord>
					spiDisable();
     922:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
					logger_memory_location += 2;
     926:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <logger_memory_location>
     92a:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <logger_memory_location+0x1>
     92e:	02 96       	adiw	r24, 0x02	; 2
     930:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <logger_memory_location+0x1>
     934:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <logger_memory_location>
					logger_eightseconds_count = 0;
     938:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <logger_eightseconds_count+0x1>
     93c:	10 92 26 01 	sts	0x0126, r1	; 0x800126 <logger_eightseconds_count>
     940:	8f ea       	ldi	r24, 0xAF	; 175
     942:	96 e3       	ldi	r25, 0x36	; 54
     944:	01 97       	sbiw	r24, 0x01	; 1
     946:	f1 f7       	brne	.-4      	; 0x944 <__stack+0x45>
     948:	00 c0       	rjmp	.+0      	; 0x94a <__stack+0x4b>
     94a:	00 00       	nop
					_delay_ms(7);	// TODO: Any chance memory write isn't done and pwr down is skipped? 
					memoryUltraDeepPowerDownEnter();
     94c:	0e 94 66 06 	call	0xccc	; 0xccc <memoryUltraDeepPowerDownEnter>
		} else if (logger_mode=='I') {
			;
		} // End of mode actions if-implemented 'switch'
		
		
		if ( !(PIND & (1<<PIND2))) { // PD2 is down - the uart cable is connected.
     950:	4a 9b       	sbis	0x09, 2	; 9
			hostCommandReceive();
     952:	0e 94 9a 01 	call	0x334	; 0x334 <hostCommandReceive>
		}
		indicatorShortBlink();
     956:	0e 94 de 00 	call	0x1bc	; 0x1bc <indicatorShortBlink>
	}// END OF MAIN LOOP
     95a:	89 cf       	rjmp	.-238    	; 0x86e <main+0x192>
     95c:	47 e3       	ldi	r20, 0x37	; 55
     95e:	51 e0       	ldi	r21, 0x01	; 1


/*
 * MAIN function, consists of initialization code and an eternal while(1) loop.
 */
int main(void) {
     960:	ad e2       	ldi	r26, 0x2D	; 45
     962:	b1 e0       	ldi	r27, 0x01	; 1
	}


	// Load MCU serial number.
	for (uint8_t i=0; i<10; i++) {
		mcu_serial_number[i] = boot_signature_byte_get(i+14);	// Read signature bytes 14-23
     964:	21 e2       	ldi	r18, 0x21	; 33
     966:	8e e0       	ldi	r24, 0x0E	; 14
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	8d 52       	subi	r24, 0x2D	; 45
     96c:	91 40       	sbci	r25, 0x01	; 1
     96e:	23 cf       	rjmp	.-442    	; 0x7b6 <main+0xda>

00000970 <max30205ReadConfig>:

/*
 * max30205ReadConfig: Read the configuration register into module variable and also return it.
 */
uint8_t max30205ReadConfig(void) {
	max30205_config = twiDRead8(MAX30205_ADDRESS, MAX30205_REG_CONF);
     970:	61 e0       	ldi	r22, 0x01	; 1
     972:	80 e9       	ldi	r24, 0x90	; 144
     974:	0e 94 7e 07 	call	0xefc	; 0xefc <twiDRead8>
     978:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
	return max30205_config;
}
     97c:	08 95       	ret

0000097e <max30205SaveConfig>:
/*
 *	max30205SaveConfiguration: Takes the configuration register variable from this module
 *	and stores it in the temperature sensor.
 */
void max30205SaveConfig(void) {
	twiDWrite8(MAX30205_ADDRESS, MAX30205_REG_CONF, max30205_config);
     97e:	40 91 3c 01 	lds	r20, 0x013C	; 0x80013c <max30205_config>
     982:	61 e0       	ldi	r22, 0x01	; 1
     984:	80 e9       	ldi	r24, 0x90	; 144
     986:	0e 94 c0 07 	call	0xf80	; 0xf80 <twiDWrite8>
     98a:	08 95       	ret

0000098c <max30205EnterShutdown>:
	twiDisable();
}


void max30205EnterShutdown(void) {
	max30205ReadConfig();
     98c:	0e 94 b8 04 	call	0x970	; 0x970 <max30205ReadConfig>
	max30205_config |= 1<<MAX30205_CONF_SHUTDOWN;
     990:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <max30205_config>
     994:	81 60       	ori	r24, 0x01	; 1
     996:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
	max30205SaveConfig();
     99a:	0e 94 bf 04 	call	0x97e	; 0x97e <max30205SaveConfig>
	twiDWrite8(MAX30205_ADDRESS, MAX30205_REG_CONF, max30205_config);
     99e:	40 91 3c 01 	lds	r20, 0x013C	; 0x80013c <max30205_config>
     9a2:	61 e0       	ldi	r22, 0x01	; 1
     9a4:	80 e9       	ldi	r24, 0x90	; 144
     9a6:	0e 94 c0 07 	call	0xf80	; 0xf80 <twiDWrite8>
     9aa:	08 95       	ret

000009ac <max30205Init>:

/*
 * Initialize MAX30205 sensor.
 */
void max30205Init(void) {
	DDRD &= ~(1<<DDRD2);						// Set D2 as input and pull-up.
     9ac:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<PORTD2);
     9ae:	5a 9a       	sbi	0x0b, 2	; 11
	// No config setup for memory chip. Default is good.
	twiEnable();
     9b0:	0e 94 58 07 	call	0xeb0	; 0xeb0 <twiEnable>
	max30205EnterShutdown();
     9b4:	0e 94 c6 04 	call	0x98c	; 0x98c <max30205EnterShutdown>
	twiDisable();
     9b8:	0e 94 6d 07 	call	0xeda	; 0xeda <twiDisable>
     9bc:	08 95       	ret

000009be <max30205StartOneShot>:
	It is the job of a higher-level module to control max30205StartOneShot and max30205ReadTemperature
	for optimization. This module only offers these two functions and nothing above them.
	
*/
void max30205StartOneShot(void) {
	if(max30205_config & (1<<MAX30205_CONF_SHUTDOWN)) {	// One-shot only works from shut-down mode. Ignored otherwise.
     9be:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <max30205_config>
     9c2:	80 ff       	sbrs	r24, 0
     9c4:	0e c0       	rjmp	.+28     	; 0x9e2 <max30205StartOneShot+0x24>
		max30205_config |= (1<<MAX30205_CONF_ONESHOT);	// Set one-shot bit in configuration variable
     9c6:	80 68       	ori	r24, 0x80	; 128
     9c8:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
		twiEnable();
     9cc:	0e 94 58 07 	call	0xeb0	; 0xeb0 <twiEnable>
		max30205SaveConfig();
     9d0:	0e 94 bf 04 	call	0x97e	; 0x97e <max30205SaveConfig>
		twiDisable();
     9d4:	0e 94 6d 07 	call	0xeda	; 0xeda <twiDisable>
		max30205_config &= ~(1<<MAX30205_CONF_ONESHOT);	// Only unset ONESHOT in variable, sensor auto-resets after one-shot completes.
     9d8:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <max30205_config>
     9dc:	8f 77       	andi	r24, 0x7F	; 127
     9de:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <max30205_config>
     9e2:	08 95       	ret

000009e4 <max30205ReadTemperature>:
		16-bit temperature reading as given by the device. Actual temperature depends on settings.

	It is the job of a higher-level module to control max30205StartOneShot and max30205ReadTemperature
	for optimization. This module only offers these two functions and nothing above them.
 */
uint16_t max30205ReadTemperature(void) {
     9e4:	cf 93       	push	r28
     9e6:	df 93       	push	r29
	uint16_t temperature;
	twiEnable();
     9e8:	0e 94 58 07 	call	0xeb0	; 0xeb0 <twiEnable>
	temperature = twiDRead16(MAX30205_ADDRESS, MAX30205_REG_TEMP);
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	80 e9       	ldi	r24, 0x90	; 144
     9f0:	0e 94 92 07 	call	0xf24	; 0xf24 <twiDRead16>
     9f4:	ec 01       	movw	r28, r24
	twiDisable();
     9f6:	0e 94 6d 07 	call	0xeda	; 0xeda <twiDisable>
	return temperature;
     9fa:	ce 01       	movw	r24, r28
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	08 95       	ret

00000a02 <_memorySingleCommand>:
		//_memoryFlagSet(MEMORY_FLAG_FULL);
	//} else {
		//memory_next_log_location += 2;			// TODO: Caution: 16-bit number may loop to 0.
	//}
	return 1;
}
     a02:	2a 98       	cbi	0x05, 2	; 5
     a04:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     a08:	2a 9a       	sbi	0x05, 2	; 5
     a0a:	08 95       	ret

00000a0c <_memorySendAddress>:
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	c8 2f       	mov	r28, r24
     a12:	d9 2f       	mov	r29, r25
     a14:	80 e0       	ldi	r24, 0x00	; 0
     a16:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     a1a:	8d 2f       	mov	r24, r29
     a1c:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     a20:	8c 2f       	mov	r24, r28
     a22:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     a26:	df 91       	pop	r29
     a28:	cf 91       	pop	r28
     a2a:	08 95       	ret

00000a2c <_memoryFlagSet>:
     a2c:	21 e0       	ldi	r18, 0x01	; 1
     a2e:	30 e0       	ldi	r19, 0x00	; 0
     a30:	02 c0       	rjmp	.+4      	; 0xa36 <_memoryFlagSet+0xa>
     a32:	22 0f       	add	r18, r18
     a34:	33 1f       	adc	r19, r19
     a36:	8a 95       	dec	r24
     a38:	e2 f7       	brpl	.-8      	; 0xa32 <_memoryFlagSet+0x6>
     a3a:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <memory_flags>
     a3e:	28 2b       	or	r18, r24
     a40:	20 93 c1 01 	sts	0x01C1, r18	; 0x8001c1 <memory_flags>
     a44:	08 95       	ret

00000a46 <_memoryBusy>:
     a46:	2a 98       	cbi	0x05, 2	; 5
     a48:	85 e0       	ldi	r24, 0x05	; 5
     a4a:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     a4e:	85 e0       	ldi	r24, 0x05	; 5
     a50:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     a54:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <memory_status_byte_1>
     a58:	2a 9a       	sbi	0x05, 2	; 5
     a5a:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <memory_status_byte_1>
     a5e:	81 70       	andi	r24, 0x01	; 1
     a60:	08 95       	ret

00000a62 <_memoryCheckBusy>:
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	c0 e0       	ldi	r28, 0x00	; 0
     a68:	d0 e0       	ldi	r29, 0x00	; 0
     a6a:	05 c0       	rjmp	.+10     	; 0xa76 <_memoryCheckBusy+0x14>
     a6c:	21 96       	adiw	r28, 0x01	; 1
     a6e:	8a e1       	ldi	r24, 0x1A	; 26
     a70:	8a 95       	dec	r24
     a72:	f1 f7       	brne	.-4      	; 0xa70 <_memoryCheckBusy+0xe>
     a74:	00 c0       	rjmp	.+0      	; 0xa76 <_memoryCheckBusy+0x14>
     a76:	0e 94 23 05 	call	0xa46	; 0xa46 <_memoryBusy>
     a7a:	88 23       	and	r24, r24
     a7c:	29 f0       	breq	.+10     	; 0xa88 <_memoryCheckBusy+0x26>
     a7e:	c8 3e       	cpi	r28, 0xE8	; 232
     a80:	83 e0       	ldi	r24, 0x03	; 3
     a82:	d8 07       	cpc	r29, r24
     a84:	99 f7       	brne	.-26     	; 0xa6c <_memoryCheckBusy+0xa>
     a86:	03 c0       	rjmp	.+6      	; 0xa8e <_memoryCheckBusy+0x2c>
     a88:	c8 3e       	cpi	r28, 0xE8	; 232
     a8a:	d3 40       	sbci	r29, 0x03	; 3
     a8c:	18 f0       	brcs	.+6      	; 0xa94 <_memoryCheckBusy+0x32>
     a8e:	85 e0       	ldi	r24, 0x05	; 5
     a90:	0e 94 16 05 	call	0xa2c	; 0xa2c <_memoryFlagSet>
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	08 95       	ret

00000a9a <memoryWriteByte>:
     a9a:	0f 93       	push	r16
     a9c:	1f 93       	push	r17
     a9e:	cf 93       	push	r28
     aa0:	8c 01       	movw	r16, r24
     aa2:	c6 2f       	mov	r28, r22
     aa4:	0e 94 31 05 	call	0xa62	; 0xa62 <_memoryCheckBusy>
     aa8:	86 e0       	ldi	r24, 0x06	; 6
     aaa:	0e 94 01 05 	call	0xa02	; 0xa02 <_memorySingleCommand>
     aae:	2a 98       	cbi	0x05, 2	; 5
     ab0:	82 e0       	ldi	r24, 0x02	; 2
     ab2:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     ab6:	c8 01       	movw	r24, r16
     ab8:	0e 94 06 05 	call	0xa0c	; 0xa0c <_memorySendAddress>
     abc:	8c 2f       	mov	r24, r28
     abe:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     ac2:	2a 9a       	sbi	0x05, 2	; 5
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	08 95       	ret

00000acc <memoryWriteWord>:
     acc:	0f 93       	push	r16
     ace:	1f 93       	push	r17
     ad0:	cf 93       	push	r28
     ad2:	df 93       	push	r29
     ad4:	8c 01       	movw	r16, r24
     ad6:	c6 2f       	mov	r28, r22
     ad8:	d7 2f       	mov	r29, r23
     ada:	0e 94 31 05 	call	0xa62	; 0xa62 <_memoryCheckBusy>
     ade:	86 e0       	ldi	r24, 0x06	; 6
     ae0:	0e 94 01 05 	call	0xa02	; 0xa02 <_memorySingleCommand>
     ae4:	2a 98       	cbi	0x05, 2	; 5
     ae6:	82 e0       	ldi	r24, 0x02	; 2
     ae8:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     aec:	c8 01       	movw	r24, r16
     aee:	0e 94 06 05 	call	0xa0c	; 0xa0c <_memorySendAddress>
     af2:	8d 2f       	mov	r24, r29
     af4:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     af8:	8c 2f       	mov	r24, r28
     afa:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     afe:	2a 9a       	sbi	0x05, 2	; 5
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	08 95       	ret

00000b0a <memoryWriteArray>:
     b0a:	ef 92       	push	r14
     b0c:	ff 92       	push	r15
     b0e:	0f 93       	push	r16
     b10:	1f 93       	push	r17
     b12:	cf 93       	push	r28
     b14:	df 93       	push	r29
     b16:	ec 01       	movw	r28, r24
     b18:	7b 01       	movw	r14, r22
     b1a:	14 2f       	mov	r17, r20
     b1c:	0e 94 31 05 	call	0xa62	; 0xa62 <_memoryCheckBusy>
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	91 e0       	ldi	r25, 0x01	; 1
     b24:	81 1b       	sub	r24, r17
     b26:	91 09       	sbc	r25, r1
     b28:	9e 01       	movw	r18, r28
     b2a:	33 27       	eor	r19, r19
     b2c:	82 17       	cp	r24, r18
     b2e:	93 07       	cpc	r25, r19
     b30:	dc f0       	brlt	.+54     	; 0xb68 <memoryWriteArray+0x5e>
     b32:	86 e0       	ldi	r24, 0x06	; 6
     b34:	0e 94 01 05 	call	0xa02	; 0xa02 <_memorySingleCommand>
     b38:	2a 98       	cbi	0x05, 2	; 5
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     b40:	ce 01       	movw	r24, r28
     b42:	0e 94 06 05 	call	0xa0c	; 0xa0c <_memorySendAddress>
     b46:	11 23       	and	r17, r17
     b48:	71 f0       	breq	.+28     	; 0xb66 <memoryWriteArray+0x5c>
     b4a:	e7 01       	movw	r28, r14
     b4c:	11 50       	subi	r17, 0x01	; 1
     b4e:	01 2f       	mov	r16, r17
     b50:	10 e0       	ldi	r17, 0x00	; 0
     b52:	0f 5f       	subi	r16, 0xFF	; 255
     b54:	1f 4f       	sbci	r17, 0xFF	; 255
     b56:	0e 0d       	add	r16, r14
     b58:	1f 1d       	adc	r17, r15
     b5a:	89 91       	ld	r24, Y+
     b5c:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     b60:	c0 17       	cp	r28, r16
     b62:	d1 07       	cpc	r29, r17
     b64:	d1 f7       	brne	.-12     	; 0xb5a <memoryWriteArray+0x50>
     b66:	2a 9a       	sbi	0x05, 2	; 5
     b68:	df 91       	pop	r29
     b6a:	cf 91       	pop	r28
     b6c:	1f 91       	pop	r17
     b6e:	0f 91       	pop	r16
     b70:	ff 90       	pop	r15
     b72:	ef 90       	pop	r14
     b74:	08 95       	ret

00000b76 <memoryDumpUpto>:
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	8c 01       	movw	r16, r24
     b80:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
     b84:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <uartEnable>
     b88:	0e 94 31 05 	call	0xa62	; 0xa62 <_memoryCheckBusy>
     b8c:	2a 98       	cbi	0x05, 2	; 5
     b8e:	83 e0       	ldi	r24, 0x03	; 3
     b90:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     b94:	80 e0       	ldi	r24, 0x00	; 0
     b96:	90 e0       	ldi	r25, 0x00	; 0
     b98:	0e 94 06 05 	call	0xa0c	; 0xa0c <_memorySendAddress>
     b9c:	01 15       	cp	r16, r1
     b9e:	11 05       	cpc	r17, r1
     ba0:	51 f4       	brne	.+20     	; 0xbb6 <memoryDumpUpto+0x40>
     ba2:	c0 e0       	ldi	r28, 0x00	; 0
     ba4:	d0 e0       	ldi	r29, 0x00	; 0
     ba6:	80 e0       	ldi	r24, 0x00	; 0
     ba8:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     bac:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
     bb0:	21 97       	sbiw	r28, 0x01	; 1
     bb2:	c9 f7       	brne	.-14     	; 0xba6 <memoryDumpUpto+0x30>
     bb4:	0b c0       	rjmp	.+22     	; 0xbcc <memoryDumpUpto+0x56>
     bb6:	c0 e0       	ldi	r28, 0x00	; 0
     bb8:	d0 e0       	ldi	r29, 0x00	; 0
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     bc0:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
     bc4:	21 96       	adiw	r28, 0x01	; 1
     bc6:	0c 17       	cp	r16, r28
     bc8:	1d 07       	cpc	r17, r29
     bca:	b9 f7       	brne	.-18     	; 0xbba <memoryDumpUpto+0x44>
     bcc:	2a 9a       	sbi	0x05, 2	; 5
     bce:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
     bd2:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <uartDisable>
     bd6:	df 91       	pop	r29
     bd8:	cf 91       	pop	r28
     bda:	1f 91       	pop	r17
     bdc:	0f 91       	pop	r16
     bde:	08 95       	ret

00000be0 <memoryScan>:
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	cd b7       	in	r28, 0x3d	; 61
     bec:	de b7       	in	r29, 0x3e	; 62
     bee:	cf 5f       	subi	r28, 0xFF	; 255
     bf0:	d1 09       	sbc	r29, r1
     bf2:	0f b6       	in	r0, 0x3f	; 63
     bf4:	f8 94       	cli
     bf6:	de bf       	out	0x3e, r29	; 62
     bf8:	0f be       	out	0x3f, r0	; 63
     bfa:	cd bf       	out	0x3d, r28	; 61
     bfc:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
     c00:	0f ef       	ldi	r16, 0xFF	; 255
     c02:	ff 24       	eor	r15, r15
     c04:	fa 94       	dec	r15
     c06:	01 c0       	rjmp	.+2      	; 0xc0a <memoryScan+0x2a>
     c08:	08 2f       	mov	r16, r24
     c0a:	2a 98       	cbi	0x05, 2	; 5
     c0c:	83 e0       	ldi	r24, 0x03	; 3
     c0e:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     c18:	80 2f       	mov	r24, r16
     c1a:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     c24:	10 e0       	ldi	r17, 0x00	; 0
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     c2c:	e1 e0       	ldi	r30, 0x01	; 1
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	ec 0f       	add	r30, r28
     c32:	fd 1f       	adc	r31, r29
     c34:	e1 0f       	add	r30, r17
     c36:	f1 1d       	adc	r31, r1
     c38:	80 83       	st	Z, r24
     c3a:	1f 5f       	subi	r17, 0xFF	; 255
     c3c:	a1 f7       	brne	.-24     	; 0xc26 <memoryScan+0x46>
     c3e:	2a 9a       	sbi	0x05, 2	; 5
     c40:	1f 2d       	mov	r17, r15
     c42:	01 c0       	rjmp	.+2      	; 0xc46 <memoryScan+0x66>
     c44:	18 2f       	mov	r17, r24
     c46:	e1 e0       	ldi	r30, 0x01	; 1
     c48:	f0 e0       	ldi	r31, 0x00	; 0
     c4a:	ec 0f       	add	r30, r28
     c4c:	fd 1f       	adc	r31, r29
     c4e:	e1 0f       	add	r30, r17
     c50:	f1 1d       	adc	r31, r1
     c52:	80 81       	ld	r24, Z
     c54:	8f 3f       	cpi	r24, 0xFF	; 255
     c56:	41 f0       	breq	.+16     	; 0xc68 <memoryScan+0x88>
     c58:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
     c5c:	81 2f       	mov	r24, r17
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	90 2b       	or	r25, r16
     c62:	8e 7f       	andi	r24, 0xFE	; 254
     c64:	02 96       	adiw	r24, 0x02	; 2
     c66:	0c c0       	rjmp	.+24     	; 0xc80 <memoryScan+0xa0>
     c68:	8f ef       	ldi	r24, 0xFF	; 255
     c6a:	81 0f       	add	r24, r17
     c6c:	11 11       	cpse	r17, r1
     c6e:	ea cf       	rjmp	.-44     	; 0xc44 <memoryScan+0x64>
     c70:	8f ef       	ldi	r24, 0xFF	; 255
     c72:	80 0f       	add	r24, r16
     c74:	01 11       	cpse	r16, r1
     c76:	c8 cf       	rjmp	.-112    	; 0xc08 <memoryScan+0x28>
     c78:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
     c7c:	80 e0       	ldi	r24, 0x00	; 0
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	c1 50       	subi	r28, 0x01	; 1
     c82:	df 4f       	sbci	r29, 0xFF	; 255
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	f8 94       	cli
     c88:	de bf       	out	0x3e, r29	; 62
     c8a:	0f be       	out	0x3f, r0	; 63
     c8c:	cd bf       	out	0x3d, r28	; 61
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	08 95       	ret

00000c9a <memoryEraseChip>:
     c9a:	86 e0       	ldi	r24, 0x06	; 6
     c9c:	0e 94 01 05 	call	0xa02	; 0xa02 <_memorySingleCommand>
     ca0:	2a 98       	cbi	0x05, 2	; 5
     ca2:	80 e6       	ldi	r24, 0x60	; 96
     ca4:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     ca8:	2a 9a       	sbi	0x05, 2	; 5
     caa:	08 95       	ret

00000cac <memoryReadStatusRegisters>:
     cac:	2a 98       	cbi	0x05, 2	; 5
     cae:	85 e0       	ldi	r24, 0x05	; 5
     cb0:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     cb4:	80 e0       	ldi	r24, 0x00	; 0
     cb6:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     cba:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <memory_status_byte_1>
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     cc4:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <memory_status_byte_2>
     cc8:	2a 9a       	sbi	0x05, 2	; 5
     cca:	08 95       	ret

00000ccc <memoryUltraDeepPowerDownEnter>:
     ccc:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
     cd0:	89 e7       	ldi	r24, 0x79	; 121
     cd2:	0e 94 01 05 	call	0xa02	; 0xa02 <_memorySingleCommand>
     cd6:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
     cda:	08 95       	ret

00000cdc <memoryUltraDeepPowerDownExitBegin>:
     cdc:	2a 98       	cbi	0x05, 2	; 5
     cde:	82 e0       	ldi	r24, 0x02	; 2
     ce0:	8a 95       	dec	r24
     ce2:	f1 f7       	brne	.-4      	; 0xce0 <memoryUltraDeepPowerDownExitBegin+0x4>
     ce4:	00 c0       	rjmp	.+0      	; 0xce6 <memoryUltraDeepPowerDownExitBegin+0xa>
     ce6:	2a 9a       	sbi	0x05, 2	; 5
     ce8:	08 95       	ret

00000cea <memoryReadMFDID>:

void memoryReadMFDID(void) {
	MEMORY_CS_SELECT;
     cea:	2a 98       	cbi	0x05, 2	; 5
	spiTradeByte(MEMORY_READ_MANUFACTURER_AND_DEVICE_ID);
     cec:	8f e9       	ldi	r24, 0x9F	; 159
     cee:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
	memory_manufacturer_id = spiTradeByte(0x00);
     cf2:	80 e0       	ldi	r24, 0x00	; 0
     cf4:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     cf8:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <memory_manufacturer_id>
	memory_device_id = spiTradeByte(0x00);
     cfc:	80 e0       	ldi	r24, 0x00	; 0
     cfe:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
	memory_device_id <<= 8;
     d02:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <memory_device_id>
     d06:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <memory_device_id+0x1>
	memory_device_id |= spiTradeByte(0x00);
     d0a:	80 e0       	ldi	r24, 0x00	; 0
     d0c:	0e 94 bb 06 	call	0xd76	; 0xd76 <spiTradeByte>
     d10:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <memory_device_id>
     d14:	30 91 3f 01 	lds	r19, 0x013F	; 0x80013f <memory_device_id+0x1>
     d18:	28 2b       	or	r18, r24
     d1a:	30 93 3f 01 	sts	0x013F, r19	; 0x80013f <memory_device_id+0x1>
     d1e:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <memory_device_id>
	MEMORY_CS_DESELECT;
     d22:	2a 9a       	sbi	0x05, 2	; 5
     d24:	08 95       	ret

00000d26 <memoryInitialize>:
/*
	memoryInit: Initialize the memory chip for first use after power-up and until
	the logger is power-cycled.
 */
void memoryInitialize(void) {
	MEMORY_CS_INIT;						// Set memory pin as output.
     d26:	22 9a       	sbi	0x04, 2	; 4
	MEMORY_CS_DESELECT;					// Init but don't assert yet.
     d28:	2a 9a       	sbi	0x05, 2	; 5
	
	memory_flags = 0;					// Clear memory flags.
     d2a:	10 92 c1 01 	sts	0x01C1, r1	; 0x8001c1 <memory_flags>
	spiEnable();
     d2e:	0e 94 a0 06 	call	0xd40	; 0xd40 <spiEnable>
	memoryReadStatusRegisters();		// Read memory chip status registers into module.
     d32:	0e 94 56 06 	call	0xcac	; 0xcac <memoryReadStatusRegisters>
	memoryReadMFDID();					// Read memory chip manufacturer and device ids.
     d36:	0e 94 75 06 	call	0xcea	; 0xcea <memoryReadMFDID>
	spiDisable();
     d3a:	0e 94 ae 06 	call	0xd5c	; 0xd5c <spiDisable>
     d3e:	08 95       	ret

00000d40 <spiEnable>:
//	MOSI0 is PB3
//	SS0 is PB2

// Initialize pins for spi communication
void spiEnable(void) {
	DDRB &= ~(1<<DDRB4);		// MISO is INPUT
     d40:	24 98       	cbi	0x04, 4	; 4
	PORTB &= ~(1<<PORTB4);		// No pull (tri-state for inputs?)
     d42:	2c 98       	cbi	0x05, 4	; 5
	
	DDRB |= (1<<DDRB3);			// MOSI output
     d44:	23 9a       	sbi	0x04, 3	; 4
	PORTB &= ~(1<<PORTB3);		// Low
     d46:	2b 98       	cbi	0x05, 3	; 5

	DDRB |= (1<<DDRB5);			// SCK out
     d48:	25 9a       	sbi	0x04, 5	; 4
	PORTB &= ~(1<<PORTB5);		// Low
     d4a:	2d 98       	cbi	0x05, 5	; 5

    PRR0 &= ~(1<<PRSPI0);								// Clock SPI0 clock, powers the module
     d4c:	e4 e6       	ldi	r30, 0x64	; 100
     d4e:	f0 e0       	ldi	r31, 0x00	; 0
     d50:	80 81       	ld	r24, Z
     d52:	8b 7f       	andi	r24, 0xFB	; 251
     d54:	80 83       	st	Z, r24
	
	SPCR0 = (1<<SPE) | (1<<MSTR) | (0<<SPR1) | (0<<SPR0);		// Enable SPI, set to Master, set prescaler.
     d56:	80 e5       	ldi	r24, 0x50	; 80
     d58:	8c bd       	out	0x2c, r24	; 44
     d5a:	08 95       	ret

00000d5c <spiDisable>:
/*
 * spiDisable: Disable the SPI module and set it for lowest power consumption.
 * TODO: Add some fault detection: SPSR0.WCOL0
 */
void spiDisable(void) {
	SPCR0 = 0;											// Disable SPI.
     d5c:	1c bc       	out	0x2c, r1	; 44
	PRR0 |= (1<<PRSPI0);								// Cut off SPI0 clock, shuts the module	
     d5e:	e4 e6       	ldi	r30, 0x64	; 100
     d60:	f0 e0       	ldi	r31, 0x00	; 0
     d62:	80 81       	ld	r24, Z
     d64:	84 60       	ori	r24, 0x04	; 4
     d66:	80 83       	st	Z, r24
	DDRB  &= ~(1<<DDRB3|1<<DDRB4|1<<DDRB5);				// MOSI0, SCK0, MISO0 pins are input
     d68:	84 b1       	in	r24, 0x04	; 4
     d6a:	87 7c       	andi	r24, 0xC7	; 199
     d6c:	84 b9       	out	0x04, r24	; 4
	PORTB |=  (1<<PORTB3|1<<PORTB4|1<<PORTB5);			// Pull-up enabled, reduces consumption.
     d6e:	85 b1       	in	r24, 0x05	; 5
     d70:	88 63       	ori	r24, 0x38	; 56
     d72:	85 b9       	out	0x05, r24	; 5
     d74:	08 95       	ret

00000d76 <spiTradeByte>:
}

// When a serial transfer is complete, the SPIF flag is set.
uint8_t spiTradeByte(uint8_t byte) {
	SPDR0 = byte;										
     d76:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR0, SPIF);			
     d78:	0d b4       	in	r0, 0x2d	; 45
     d7a:	07 fe       	sbrs	r0, 7
     d7c:	fd cf       	rjmp	.-6      	; 0xd78 <spiTradeByte+0x2>
	return SPDR0;
     d7e:	8e b5       	in	r24, 0x2e	; 46
}
     d80:	08 95       	ret

00000d82 <systemLabelLoad>:
 * Read label from EEPROM into module, then return it.
 */
uint16_t systemLabelRead(void) {
	systemLabelLoad();
	return systemLabelGet();
}
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	0e 94 2f 08 	call	0x105e	; 0x105e <eeprom_read_byte>
     d8e:	c8 2f       	mov	r28, r24
     d90:	d0 e0       	ldi	r29, 0x00	; 0
     d92:	dc 2f       	mov	r29, r28
     d94:	cc 27       	eor	r28, r28
     d96:	d0 93 c4 01 	sts	0x01C4, r29	; 0x8001c4 <system_label+0x1>
     d9a:	c0 93 c3 01 	sts	0x01C3, r28	; 0x8001c3 <system_label>
     d9e:	81 e0       	ldi	r24, 0x01	; 1
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	0e 94 2f 08 	call	0x105e	; 0x105e <eeprom_read_byte>
     da6:	c8 2b       	or	r28, r24
     da8:	d0 93 c4 01 	sts	0x01C4, r29	; 0x8001c4 <system_label+0x1>
     dac:	c0 93 c3 01 	sts	0x01C3, r28	; 0x8001c3 <system_label>
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	08 95       	ret

00000db6 <systemLabelGet>:
     db6:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <system_label>
     dba:	90 91 c4 01 	lds	r25, 0x01C4	; 0x8001c4 <system_label+0x1>
     dbe:	08 95       	ret

00000dc0 <systemLabelWrite>:

/*
 * Write two bytes of label to EEPROM. First byte is MSB, second byte is LSB.
 */
void systemLabelWrite(uint8_t label_msb, uint8_t label_lsb) {
     dc0:	cf 93       	push	r28
     dc2:	c6 2f       	mov	r28, r22
	eeprom_update_byte((uint8_t *) SYSTEM_LABEL_ADDR_MSB, label_msb);
     dc4:	68 2f       	mov	r22, r24
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	0e 94 37 08 	call	0x106e	; 0x106e <eeprom_update_byte>
	eeprom_update_byte((uint8_t *) SYSTEM_LABEL_ADDR_LSB, label_lsb);
     dce:	6c 2f       	mov	r22, r28
     dd0:	81 e0       	ldi	r24, 0x01	; 1
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	0e 94 37 08 	call	0x106e	; 0x106e <eeprom_update_byte>
	// Verify EEPROM write busy doesn't cause any problems here.
	systemLabelLoad();
     dd8:	0e 94 c1 06 	call	0xd82	; 0xd82 <systemLabelLoad>
}
     ddc:	cf 91       	pop	r28
     dde:	08 95       	ret

00000de0 <systemBootloaderGetAddress>:

uint16_t systemBootloaderGetAddress(void) {
	// Load bootloader start address and firmware available pages
	uint8_t bootsz_bits = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
     de0:	e3 e0       	ldi	r30, 0x03	; 3
     de2:	f0 e0       	ldi	r31, 0x00	; 0
     de4:	89 e0       	ldi	r24, 0x09	; 9
     de6:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
     dea:	84 91       	lpm	r24, Z
	bootsz_bits = bootsz_bits & 0b00000110;					// Keep only bootsz bits. 1: unseet, 0: set
     dec:	86 70       	andi	r24, 0x06	; 6
	bootsz_bits = bootsz_bits >> 1;									// Move bootsz bits to base
	bootsz_bits = ~(bootsz_bits) & 0b11;							// Reverse bootsz bits and filter out other bits
     dee:	86 95       	lsr	r24
     df0:	80 95       	com	r24
	// Bootsz bits are now 0-3 representing 4, 8, 16, or 32 pages of boot sector.
	system_bootloader_address = 0x8000 - (1<<bootsz_bits)*512;		// bootsector size = math.pow(2, bootsz) * 512
     df2:	83 70       	andi	r24, 0x03	; 3
     df4:	20 e0       	ldi	r18, 0x00	; 0
     df6:	32 e0       	ldi	r19, 0x02	; 2
     df8:	02 c0       	rjmp	.+4      	; 0xdfe <systemBootloaderGetAddress+0x1e>
     dfa:	22 0f       	add	r18, r18
     dfc:	33 1f       	adc	r19, r19
     dfe:	8a 95       	dec	r24
     e00:	e2 f7       	brpl	.-8      	; 0xdfa <systemBootloaderGetAddress+0x1a>
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	90 e8       	ldi	r25, 0x80	; 128
     e06:	82 1b       	sub	r24, r18
     e08:	93 0b       	sbc	r25, r19
     e0a:	90 93 c6 01 	sts	0x01C6, r25	; 0x8001c6 <system_bootloader_address+0x1>
     e0e:	80 93 c5 01 	sts	0x01C5, r24	; 0x8001c5 <system_bootloader_address>
	return system_bootloader_address;
}
     e12:	08 95       	ret

00000e14 <_twiWaitForTWINT>:
	if(!(_twiStatusIs(TW_MT_SLA_ACK) || _twiStatusIs(TW_MR_SLA_ACK)) ) {
		_twiErrorFlag(TWI_ERROR_SLACK);
		return twiErrorGetFlags();
	}
    return 0;
}
     e14:	ec eb       	ldi	r30, 0xBC	; 188
     e16:	f0 e0       	ldi	r31, 0x00	; 0
     e18:	80 81       	ld	r24, Z
     e1a:	88 23       	and	r24, r24
     e1c:	ec f7       	brge	.-6      	; 0xe18 <_twiWaitForTWINT+0x4>
     e1e:	08 95       	ret

00000e20 <_twiTransmitNoAck>:
     e20:	84 e8       	ldi	r24, 0x84	; 132
     e22:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     e26:	0e 94 0a 07 	call	0xe14	; 0xe14 <_twiWaitForTWINT>
     e2a:	08 95       	ret

00000e2c <_twiStatusIs>:
     e2c:	20 91 b9 00 	lds	r18, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
     e30:	28 7f       	andi	r18, 0xF8	; 248
     e32:	30 e0       	ldi	r19, 0x00	; 0
     e34:	48 2f       	mov	r20, r24
     e36:	50 e0       	ldi	r21, 0x00	; 0
     e38:	81 e0       	ldi	r24, 0x01	; 1
     e3a:	24 17       	cp	r18, r20
     e3c:	35 07       	cpc	r19, r21
     e3e:	09 f0       	breq	.+2      	; 0xe42 <_twiStatusIs+0x16>
     e40:	80 e0       	ldi	r24, 0x00	; 0
     e42:	08 95       	ret

00000e44 <_twiStartRegisterWrite>:



void _twiStartRegisterWrite(uint8_t slave_address, uint8_t register_address) {
     e44:	0f 93       	push	r16
     e46:	1f 93       	push	r17
     e48:	cf 93       	push	r28
     e4a:	df 93       	push	r29
     e4c:	08 2f       	mov	r16, r24
     e4e:	16 2f       	mov	r17, r22
 * _before_ clearing this flag.
 * A START condition is signaled by pulling the SDA line from
 * high to low when the SCL line is high.
 */
static void _twiSetStartCondition(void) {
	TWCR0 = (1<<TWINT)|(1<<TWEN)|(1<<TWSTA);
     e50:	84 ea       	ldi	r24, 0xA4	; 164
     e52:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	_twiWaitForTWINT();
     e56:	0e 94 0a 07 	call	0xe14	; 0xe14 <_twiWaitForTWINT>


void _twiStartRegisterWrite(uint8_t slave_address, uint8_t register_address) {
	// Set start condition on TWI bus
	_twiSetStartCondition();
	if( !_twiStatusIs(TW_START)) {
     e5a:	88 e0       	ldi	r24, 0x08	; 8
     e5c:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>

/*
 * Send a data byte on the TWI line, don't set 9th ACK bit.
 */
void _twiSend(uint8_t data) {
	TWDR0 = data;
     e60:	cb eb       	ldi	r28, 0xBB	; 187
     e62:	d0 e0       	ldi	r29, 0x00	; 0
     e64:	08 83       	st	Y, r16
	_twiTransmitNoAck();
     e66:	0e 94 10 07 	call	0xe20	; 0xe20 <_twiTransmitNoAck>
		;// Do nothing here
	}
	
	// Send slave address with write bit
	_twiSend(TWI_SLA_WRITE(slave_address));
	if ( !_twiStatusIs(TW_MT_SLA_ACK) ) {
     e6a:	88 e1       	ldi	r24, 0x18	; 24
     e6c:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>

/*
 * Send a data byte on the TWI line, don't set 9th ACK bit.
 */
void _twiSend(uint8_t data) {
	TWDR0 = data;
     e70:	18 83       	st	Y, r17
	_twiTransmitNoAck();
     e72:	0e 94 10 07 	call	0xe20	; 0xe20 <_twiTransmitNoAck>
		;	// Do nothing yet
	}
	
	// Send slave register address we want to access (considered data).
	_twiSend(register_address);
	if ( !_twiStatusIs(TW_MT_DATA_ACK) ) {
     e76:	88 e2       	ldi	r24, 0x28	; 40
     e78:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>
		;	// Do nothing yet
	}
}
     e7c:	df 91       	pop	r29
     e7e:	cf 91       	pop	r28
     e80:	1f 91       	pop	r17
     e82:	0f 91       	pop	r16
     e84:	08 95       	ret

00000e86 <_twiStartRegisterRead>:

/*
 * Internal function: Start a register-read transaction on TWI
 */
void _twiStartRegisterRead(uint8_t slave_address, uint8_t register_address) {
     e86:	cf 93       	push	r28
     e88:	c8 2f       	mov	r28, r24
	_twiStartRegisterWrite(slave_address, register_address);
     e8a:	0e 94 22 07 	call	0xe44	; 0xe44 <_twiStartRegisterWrite>
 * _before_ clearing this flag.
 * A START condition is signaled by pulling the SDA line from
 * high to low when the SCL line is high.
 */
static void _twiSetStartCondition(void) {
	TWCR0 = (1<<TWINT)|(1<<TWEN)|(1<<TWSTA);
     e8e:	84 ea       	ldi	r24, 0xA4	; 164
     e90:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	_twiWaitForTWINT();
     e94:	0e 94 0a 07 	call	0xe14	; 0xe14 <_twiWaitForTWINT>
void _twiStartRegisterRead(uint8_t slave_address, uint8_t register_address) {
	_twiStartRegisterWrite(slave_address, register_address);
	
	// Set start condition again, here considered a re-start.
	_twiSetStartCondition();
	if((TWSR0 & 0xF8) != TW_REP_START) {
     e98:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
		;	// Do nothing yet.
	}

	// Send slave address with read bit.
	_twiSend(TWI_SLA_READ(slave_address));
     e9c:	c1 60       	ori	r28, 0x01	; 1

/*
 * Send a data byte on the TWI line, don't set 9th ACK bit.
 */
void _twiSend(uint8_t data) {
	TWDR0 = data;
     e9e:	c0 93 bb 00 	sts	0x00BB, r28	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	_twiTransmitNoAck();
     ea2:	0e 94 10 07 	call	0xe20	; 0xe20 <_twiTransmitNoAck>
		;	// Do nothing yet.
	}

	// Send slave address with read bit.
	_twiSend(TWI_SLA_READ(slave_address));
	if ( !_twiStatusIs(TW_MR_SLA_ACK) ) {
     ea6:	80 e4       	ldi	r24, 0x40	; 64
     ea8:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>
		;	// Do nothing yet.
	}
	
}
     eac:	cf 91       	pop	r28
     eae:	08 95       	ret

00000eb0 <twiEnable>:
 * Note that the internal pull-ups in the AVR pads can be enabled by
 * setting the PORT bits corresponding to the SCL and SDA pins, as explained in the I/O Port section. The
 * internal pull-ups can in some systems eliminate the need for external ones (DS p.303).
 */
void twiEnable(void) {
	PRR0  &= ~(1<<PRTWI0);					// Start clock to TWI peripheral.
     eb0:	e4 e6       	ldi	r30, 0x64	; 100
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	80 81       	ld	r24, Z
     eb6:	8f 77       	andi	r24, 0x7F	; 127
     eb8:	80 83       	st	Z, r24
	//TWSR0 &= ~((1<<TWPS1)|(1<<TWPS0));		// Prescaler, not needed if it's 0b00.
	TWSR0 &= ~(0b11);						// Clear prescaler bits
     eba:	e9 eb       	ldi	r30, 0xB9	; 185
     ebc:	f0 e0       	ldi	r31, 0x00	; 0
     ebe:	80 81       	ld	r24, Z
     ec0:	8c 7f       	andi	r24, 0xFC	; 252
     ec2:	80 83       	st	Z, r24
	TWSR0 |= (0<<TWPS1|0<<TWPS0);			// Set prescaler bits: 00 for 1, 01 for 4, 10 for 16, 11 for 64.
     ec4:	80 81       	ld	r24, Z
     ec6:	80 83       	st	Z, r24
	TWBR0 = 32;								// 32 for 100k, 2 for 400k (with 8MHz, prescaler at 1).
     ec8:	80 e2       	ldi	r24, 0x20	; 32
     eca:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
	TWCR0 |= (1<<TWEN);						// Enable TWI
     ece:	ec eb       	ldi	r30, 0xBC	; 188
     ed0:	f0 e0       	ldi	r31, 0x00	; 0
     ed2:	80 81       	ld	r24, Z
     ed4:	84 60       	ori	r24, 0x04	; 4
     ed6:	80 83       	st	Z, r24
     ed8:	08 95       	ret

00000eda <twiDisable>:
}

// Deactivate the TWI0 module and set SDA and SCL pins to low power consumption.
void twiDisable(void) {
	TWCR0 &= ~(1<<TWEN);					// Disable TWI, may not be necessary
     eda:	ec eb       	ldi	r30, 0xBC	; 188
     edc:	f0 e0       	ldi	r31, 0x00	; 0
     ede:	80 81       	ld	r24, Z
     ee0:	8b 7f       	andi	r24, 0xFB	; 251
     ee2:	80 83       	st	Z, r24
	PRR0  |= (1<<PRTWI0);					// Stop TWI clock
     ee4:	e4 e6       	ldi	r30, 0x64	; 100
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	80 81       	ld	r24, Z
     eea:	80 68       	ori	r24, 0x80	; 128
     eec:	80 83       	st	Z, r24
	DDRC  &= ~((1<<DDRC4)|(1<<DDRC5));		// Set TWI pins as inputs
     eee:	87 b1       	in	r24, 0x07	; 7
     ef0:	8f 7c       	andi	r24, 0xCF	; 207
     ef2:	87 b9       	out	0x07, r24	; 7
	PORTC |= ((1<<PORTC4)|(1<<PORTC5));		// Pull them up to reduce power consumption.
     ef4:	88 b1       	in	r24, 0x08	; 8
     ef6:	80 63       	ori	r24, 0x30	; 48
     ef8:	88 b9       	out	0x08, r24	; 8
     efa:	08 95       	ret

00000efc <twiDRead8>:
 *		register_address:	The 8-bit address to be read from slave.
 *
 *	Output:
 *		8-bit value of the register.
 */
uint8_t twiDRead8(uint8_t slave_address, uint8_t register_address) {
     efc:	cf 93       	push	r28
	uint8_t register_data;
	_twiStartRegisterRead(slave_address, register_address);
     efe:	0e 94 43 07 	call	0xe86	; 0xe86 <_twiStartRegisterRead>
	_twiTransmitAck();
	return(TWDR0);
}
// Read in from slave (or master) without sending ack
uint8_t _twiReadNoAck(void) {
	_twiTransmitNoAck();
     f02:	0e 94 10 07 	call	0xe20	; 0xe20 <_twiTransmitNoAck>
	return(TWDR0);
     f06:	c0 91 bb 00 	lds	r28, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
uint8_t twiDRead8(uint8_t slave_address, uint8_t register_address) {
	uint8_t register_data;
	_twiStartRegisterRead(slave_address, register_address);

	register_data = _twiReadNoAck();
	if ( !_twiStatusIs(TW_MR_DATA_NACK) ) {
     f0a:	88 e5       	ldi	r24, 0x58	; 88
     f0c:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>
     f10:	88 23       	and	r24, r24
     f12:	21 f0       	breq	.+8      	; 0xf1c <twiDRead8+0x20>
 * _twiSetStopCondition: Set a stop condition on the TWI line
 * A STOP condition is signaled by pulling the SDA line from
 * low to high when the SCL line is high.
 */
void _twiSetStopCondition(void) {
	TWCR0 = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     f14:	84 e9       	ldi	r24, 0x94	; 148
     f16:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <twiDRead8+0x22>
	uint8_t register_data;
	_twiStartRegisterRead(slave_address, register_address);

	register_data = _twiReadNoAck();
	if ( !_twiStatusIs(TW_MR_DATA_NACK) ) {
		return 0xFA;
     f1c:	ca ef       	ldi	r28, 0xFA	; 250
	}
	
	// Set stop condition
	_twiSetStopCondition();
	return register_data;
}
     f1e:	8c 2f       	mov	r24, r28
     f20:	cf 91       	pop	r28
     f22:	08 95       	ret

00000f24 <twiDRead16>:

uint16_t twiDRead16(uint8_t slave_address, uint8_t register_address) {
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
	uint8_t data_MSB;
	uint8_t data_LSB;
	uint16_t data_16b;
	_twiStartRegisterRead(slave_address, register_address);
     f28:	0e 94 43 07 	call	0xe86	; 0xe86 <_twiStartRegisterRead>
/*
 * twiTransmitAck: In Master mode, trigger data transmission and enable setting
 * the 9th ACK bit to signal the sender to continue transmission.
 */
static void _twiTransmitAck(void) {
	TWCR0 = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
     f2c:	84 ec       	ldi	r24, 0xC4	; 196
     f2e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	_twiWaitForTWINT();
     f32:	0e 94 0a 07 	call	0xe14	; 0xe14 <_twiWaitForTWINT>
}

// Read in from slave, sending ACK when done (sets TWEA).
uint8_t _twiReadAck(void) {
	_twiTransmitAck();
	return(TWDR0);
     f36:	d0 91 bb 00 	lds	r29, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	uint8_t data_MSB;
	uint8_t data_LSB;
	uint16_t data_16b;
	_twiStartRegisterRead(slave_address, register_address);
	data_MSB = _twiReadAck();
	if ( !_twiStatusIs(TW_MR_DATA_ACK)) {
     f3a:	80 e5       	ldi	r24, 0x50	; 80
     f3c:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>
     f40:	88 23       	and	r24, r24
     f42:	b1 f0       	breq	.+44     	; 0xf70 <twiDRead16+0x4c>
	_twiTransmitAck();
	return(TWDR0);
}
// Read in from slave (or master) without sending ack
uint8_t _twiReadNoAck(void) {
	_twiTransmitNoAck();
     f44:	0e 94 10 07 	call	0xe20	; 0xe20 <_twiTransmitNoAck>
	return(TWDR0);
     f48:	c0 91 bb 00 	lds	r28, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	data_MSB = _twiReadAck();
	if ( !_twiStatusIs(TW_MR_DATA_ACK)) {
		return 0xFD;
	}
	data_LSB = _twiReadNoAck();
	if ( !_twiStatusIs(TW_MR_DATA_NACK)) {
     f4c:	88 e5       	ldi	r24, 0x58	; 88
     f4e:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>
     f52:	88 23       	and	r24, r24
     f54:	81 f0       	breq	.+32     	; 0xf76 <twiDRead16+0x52>
		return 0xFE;
	}
	
	uartSendByte(data_MSB);
     f56:	8d 2f       	mov	r24, r29
     f58:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
	uartSendByte(data_LSB);
     f5c:	8c 2f       	mov	r24, r28
     f5e:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
 * _twiSetStopCondition: Set a stop condition on the TWI line
 * A STOP condition is signaled by pulling the SDA line from
 * low to high when the SCL line is high.
 */
void _twiSetStopCondition(void) {
	TWCR0 = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     f62:	84 e9       	ldi	r24, 0x94	; 148
     f64:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	uartSendByte(data_MSB);
	uartSendByte(data_LSB);
	
	_twiSetStopCondition();
	data_16b = data_MSB;
	data_16b <<= 8;
     f68:	8c 2f       	mov	r24, r28
     f6a:	90 e0       	ldi	r25, 0x00	; 0
	data_16b |= data_LSB;
	return data_16b;
     f6c:	9d 2b       	or	r25, r29
     f6e:	05 c0       	rjmp	.+10     	; 0xf7a <twiDRead16+0x56>
	uint8_t data_LSB;
	uint16_t data_16b;
	_twiStartRegisterRead(slave_address, register_address);
	data_MSB = _twiReadAck();
	if ( !_twiStatusIs(TW_MR_DATA_ACK)) {
		return 0xFD;
     f70:	8d ef       	ldi	r24, 0xFD	; 253
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	02 c0       	rjmp	.+4      	; 0xf7a <twiDRead16+0x56>
	}
	data_LSB = _twiReadNoAck();
	if ( !_twiStatusIs(TW_MR_DATA_NACK)) {
		return 0xFE;
     f76:	8e ef       	ldi	r24, 0xFE	; 254
     f78:	90 e0       	ldi	r25, 0x00	; 0
	_twiSetStopCondition();
	data_16b = data_MSB;
	data_16b <<= 8;
	data_16b |= data_LSB;
	return data_16b;
}
     f7a:	df 91       	pop	r29
     f7c:	cf 91       	pop	r28
     f7e:	08 95       	ret

00000f80 <twiDWrite8>:

void twiDWrite8(uint8_t slave_address, uint8_t register_address, uint8_t write_value) {
     f80:	cf 93       	push	r28
     f82:	c4 2f       	mov	r28, r20
	_twiStartRegisterWrite(slave_address, register_address);
     f84:	0e 94 22 07 	call	0xe44	; 0xe44 <_twiStartRegisterWrite>

/*
 * Send a data byte on the TWI line, don't set 9th ACK bit.
 */
void _twiSend(uint8_t data) {
	TWDR0 = data;
     f88:	c0 93 bb 00 	sts	0x00BB, r28	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
	_twiTransmitNoAck();
     f8c:	0e 94 10 07 	call	0xe20	; 0xe20 <_twiTransmitNoAck>
}

void twiDWrite8(uint8_t slave_address, uint8_t register_address, uint8_t write_value) {
	_twiStartRegisterWrite(slave_address, register_address);
	_twiSend(write_value);
	if( !_twiStatusIs(TW_MT_DATA_ACK) ) {
     f90:	88 e2       	ldi	r24, 0x28	; 40
     f92:	0e 94 16 07 	call	0xe2c	; 0xe2c <_twiStatusIs>
 * _twiSetStopCondition: Set a stop condition on the TWI line
 * A STOP condition is signaled by pulling the SDA line from
 * low to high when the SCL line is high.
 */
void _twiSetStopCondition(void) {
	TWCR0 = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     f96:	84 e9       	ldi	r24, 0x94	; 148
     f98:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
	_twiSend(write_value);
	if( !_twiStatusIs(TW_MT_DATA_ACK) ) {
		;	// Do something
	}
	_twiSetStopCondition();
}
     f9c:	cf 91       	pop	r28
     f9e:	08 95       	ret

00000fa0 <uartEnable>:
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
	;
	/* Get and return received data from buffer */
	return UDR0;
}
     fa0:	e4 e6       	ldi	r30, 0x64	; 100
     fa2:	f0 e0       	ldi	r31, 0x00	; 0
     fa4:	80 81       	ld	r24, Z
     fa6:	8d 7f       	andi	r24, 0xFD	; 253
     fa8:	80 83       	st	Z, r24
     faa:	88 e1       	ldi	r24, 0x18	; 24
     fac:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     fb0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     fb4:	10 92 c4 00 	sts	0x00C4, r1	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     fb8:	e0 ec       	ldi	r30, 0xC0	; 192
     fba:	f0 e0       	ldi	r31, 0x00	; 0
     fbc:	80 81       	ld	r24, Z
     fbe:	82 60       	ori	r24, 0x02	; 2
     fc0:	80 83       	st	Z, r24
     fc2:	80 81       	ld	r24, Z
     fc4:	8f 7d       	andi	r24, 0xDF	; 223
     fc6:	80 83       	st	Z, r24
     fc8:	8e e0       	ldi	r24, 0x0E	; 14
     fca:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     fce:	08 95       	ret

00000fd0 <uartDisable>:
     fd0:	82 e4       	ldi	r24, 0x42	; 66
     fd2:	8a 95       	dec	r24
     fd4:	f1 f7       	brne	.-4      	; 0xfd2 <uartDisable+0x2>
     fd6:	00 c0       	rjmp	.+0      	; 0xfd8 <uartDisable+0x8>
     fd8:	e1 ec       	ldi	r30, 0xC1	; 193
     fda:	f0 e0       	ldi	r31, 0x00	; 0
     fdc:	80 81       	ld	r24, Z
     fde:	87 76       	andi	r24, 0x67	; 103
     fe0:	80 83       	st	Z, r24
     fe2:	e4 e6       	ldi	r30, 0x64	; 100
     fe4:	f0 e0       	ldi	r31, 0x00	; 0
     fe6:	80 81       	ld	r24, Z
     fe8:	82 60       	ori	r24, 0x02	; 2
     fea:	80 83       	st	Z, r24
     fec:	8a b1       	in	r24, 0x0a	; 10
     fee:	8c 7f       	andi	r24, 0xFC	; 252
     ff0:	8a b9       	out	0x0a, r24	; 10
     ff2:	8b b1       	in	r24, 0x0b	; 11
     ff4:	83 60       	ori	r24, 0x03	; 3
     ff6:	8b b9       	out	0x0b, r24	; 11
     ff8:	08 95       	ret

00000ffa <uartRxInterruptEnable>:
     ffa:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     ffe:	84 ff       	sbrs	r24, 4
    1000:	05 c0       	rjmp	.+10     	; 0x100c <uartRxInterruptEnable+0x12>
    1002:	e1 ec       	ldi	r30, 0xC1	; 193
    1004:	f0 e0       	ldi	r31, 0x00	; 0
    1006:	80 81       	ld	r24, Z
    1008:	80 68       	ori	r24, 0x80	; 128
    100a:	80 83       	st	Z, r24
    100c:	08 95       	ret

0000100e <uartSendByte>:
    100e:	e0 ec       	ldi	r30, 0xC0	; 192
    1010:	f0 e0       	ldi	r31, 0x00	; 0
    1012:	90 81       	ld	r25, Z
    1014:	95 ff       	sbrs	r25, 5
    1016:	fd cf       	rjmp	.-6      	; 0x1012 <uartSendByte+0x4>
    1018:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    101c:	08 95       	ret

0000101e <uartSendWord>:

/*
 * Send a 16-bit unsigned word over the uart line, MSB first.
 */
void uartSendWord(uint16_t data) {
    101e:	cf 93       	push	r28
    1020:	c8 2f       	mov	r28, r24
	uartSendByte((uint8_t) (data>>8));
    1022:	89 2f       	mov	r24, r25
    1024:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
	uartSendByte((uint8_t) data);	
    1028:	8c 2f       	mov	r24, r28
    102a:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>
}
    102e:	cf 91       	pop	r28
    1030:	08 95       	ret

00001032 <uartSendString>:


/*
 * Send a string of up to 255 characters over USART
 */
void uartSendString(const char myString[]) {
    1032:	0f 93       	push	r16
    1034:	1f 93       	push	r17
    1036:	cf 93       	push	r28
    1038:	fc 01       	movw	r30, r24
    for (uint8_t i=0; myString[i]; i++)
    103a:	80 81       	ld	r24, Z
    103c:	88 23       	and	r24, r24
    103e:	59 f0       	breq	.+22     	; 0x1056 <uartSendString+0x24>
    1040:	8f 01       	movw	r16, r30
    1042:	c0 e0       	ldi	r28, 0x00	; 0
        uartSendByte(myString[i]);
    1044:	0e 94 07 08 	call	0x100e	; 0x100e <uartSendByte>

/*
 * Send a string of up to 255 characters over USART
 */
void uartSendString(const char myString[]) {
    for (uint8_t i=0; myString[i]; i++)
    1048:	cf 5f       	subi	r28, 0xFF	; 255
    104a:	f8 01       	movw	r30, r16
    104c:	ec 0f       	add	r30, r28
    104e:	f1 1d       	adc	r31, r1
    1050:	80 81       	ld	r24, Z
    1052:	81 11       	cpse	r24, r1
    1054:	f7 cf       	rjmp	.-18     	; 0x1044 <uartSendString+0x12>
        uartSendByte(myString[i]);
}
    1056:	cf 91       	pop	r28
    1058:	1f 91       	pop	r17
    105a:	0f 91       	pop	r16
    105c:	08 95       	ret

0000105e <eeprom_read_byte>:
    105e:	f9 99       	sbic	0x1f, 1	; 31
    1060:	fe cf       	rjmp	.-4      	; 0x105e <eeprom_read_byte>
    1062:	92 bd       	out	0x22, r25	; 34
    1064:	81 bd       	out	0x21, r24	; 33
    1066:	f8 9a       	sbi	0x1f, 0	; 31
    1068:	99 27       	eor	r25, r25
    106a:	80 b5       	in	r24, 0x20	; 32
    106c:	08 95       	ret

0000106e <eeprom_update_byte>:
    106e:	26 2f       	mov	r18, r22

00001070 <eeprom_update_r18>:
    1070:	f9 99       	sbic	0x1f, 1	; 31
    1072:	fe cf       	rjmp	.-4      	; 0x1070 <eeprom_update_r18>
    1074:	92 bd       	out	0x22, r25	; 34
    1076:	81 bd       	out	0x21, r24	; 33
    1078:	f8 9a       	sbi	0x1f, 0	; 31
    107a:	01 97       	sbiw	r24, 0x01	; 1
    107c:	00 b4       	in	r0, 0x20	; 32
    107e:	02 16       	cp	r0, r18
    1080:	39 f0       	breq	.+14     	; 0x1090 <eeprom_update_r18+0x20>
    1082:	1f ba       	out	0x1f, r1	; 31
    1084:	20 bd       	out	0x20, r18	; 32
    1086:	0f b6       	in	r0, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	fa 9a       	sbi	0x1f, 2	; 31
    108c:	f9 9a       	sbi	0x1f, 1	; 31
    108e:	0f be       	out	0x3f, r0	; 63
    1090:	08 95       	ret

00001092 <_exit>:
    1092:	f8 94       	cli

00001094 <__stop_program>:
    1094:	ff cf       	rjmp	.-2      	; 0x1094 <__stop_program>
